#!/usr/bin/perl
#Version: 0.37
# tes3cmd: command line tool to do various hackage on a TES3 plugin
# Copyright 2009 by John Moonsugar
# Distributed as part of the mlox project:
#   http://code.google.com/p/mlox/
# under the MIT License:
#   http://code.google.com/p/mlox/source/browse/trunk/License.txt
# Documentation:
#   http://code.google.com/p/mlox/wiki/Tes3cmd

use Cwd;
use File::Basename;
use File::Copy;
use Getopt::Std;
use Data::Dumper;
use strict;

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

my $ESP_USAGE = q{Usage: tes3cmd esp OPTIONS master...

OPTIONS
 -D        turn on debug output

Converts input master into a plugin (.esp).

Example:

# output is: plugin.esp
tes3cmd esp plugin.esm
};

sub opts_esp {
    $_[0] && do { die $ESP_USAGE; };
    getopts('D') or die $ESP_USAGE;
}

my $ESM_USAGE = q{Usage: tes3cmd esm OPTIONS plugin...

OPTIONS
 -D        turn on debug output

Converts input plugin into a master (.esm).

Example:

# output is: plugin.esm
tes3cmd esm plugin.esp
};

sub opts_esm {
    $_[0] && do { die $ESM_USAGE; };
    getopts('D') or die $ESM_USAGE;
}

my $MODIFY_USAGE = q{Usage: tes3cmd modify OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -i ids    only modify the records with ids matching the given comma-delimited
           list of regular expression patterns.
 -f file   file containing list of regexes to match, one per line.
 -F file   file containing list of regexes to not match, one per line.
 -m regex  only modify records that match given regular expression.
 -M regex  only modify records that do not match given regular expression.
 -s        only modify the subrecords that matched.
 -t types  only modify the records matching the given comma-delimited
           list of record types.
 -r /a/b/  replace regex a with b. you can use any character instead of the slash.
 -e 'code' specify a string of Perl code to run on each matched record.
 -p file   specify a file containing Perl code to load.

Modifies records/subrecords from the plugin. You can really damage things with
this command, so be careful!

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Examples:

# Modify all records with IDs matching "foo":
tes3cmd modify -i foo -e 'TBD' plugin.esp

# Modify all subrecords of type NPC_.NPCO that match "Ring des Skeletts" from
# savegame: quicksave.ess
tes3cmd modify -s npc_.npco -m "Ring des Skeletts" -p myprogram quicksave.ess
};

sub opts_modify {
    $_[0] && do { die $MODIFY_USAGE; };
    getopts('Df:F:e:i:m:M:p:r:st:') or die $MODIFY_USAGE;
}

my $CELLNAMEPATCH_USAGE = q{Usage: tes3cmd cellnamepatch

OPTIONS
 -D        turn on debug output

Creates a patch plugin to ensure all renamed cells end up in the player's game.

Examples:

# Create the patch plugin "cellnamepatch.esp"
tes3cmd cellnamepatch

};

sub opts_cellnamepatch {
    $_[0] && do { die $CELLNAMEPATCH_USAGE; };
    getopts('D') or die $CELLNAMEPATCH_USAGE;
}


my $FOGPATCH_USAGE = q{Usage: tes3cmd fogpatch

OPTIONS
 -D        turn on debug output

Creates a patch plugin to fix all cells in your plugins that would trigger the fogbug.

Examples:

# Create the patch plugin fogpatch.esp
tes3cmd fogpatch

};

sub opts_fogpatch {
    $_[0] && do { die $FOGPATCH_USAGE; };
    getopts('D') or die $FOGPATCH_USAGE;
}


my $DELETE_USAGE = q{Usage: tes3cmd delete OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -i ids    only delete the records with ids matching the given comma-delimited
           list of regular expression patterns.
 -f file   file containing list of regexes to match, one per line.
 -F file   file containing list of regexes to not match, one per line.
 -m regex  only delete records that match given regular expression.
 -M regex  only delete records that do not match given regular expression.
 -s        only delete the subrecords that matched.
 -t types  only delete the records matching the given comma-delimited
           list of record types.

Deletes records/subrecords from the plugin. You can really damage things with
this command, so be careful!

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Examples:

# Delete all records with IDs matching "foo":
tes3cmd delete -i foo plugin.esp

# Delete all subrecords of type NPC_.NPCO that match "Ring des Skeletts" from
# savegame: quicksave.ess
tes3cmd delete -s npc_.npco -m "Ring des Skeletts" quicksave.ess
};

sub opts_delete {
    $_[0] && do { die $DELETE_USAGE; };
    getopts('Df:i:m:M:st:') or die $DELETE_USAGE;
}


my $OVERDIAL_USAGE = q{Usage: tes3cmd overdial OPTIONS plugin...

OPTIONS
 -D   turn on debug output
 -1   only test to see if dialog in the first plugin is overlapped. (by default
      all plugins are checked against all other plugins, which is an n-squared
      operation, meaning "possibly very slow").

Prints the IDs of dialog records that overlap from the set of given plugins.

An overlap is defined as a dialog (DIAL) Topic from one plugin that entirely
contains a dialog Topic from another plugin as a substring. For example, the
mod "White Wolf of Lokken" has a dialog topic "to rescue me" which overlaps
with the dialog topic "rescue me" from "Suran Underworld", which causes the
"Special Guest" quest from SU to get stuck because Ylarra won't offer the
topic "rescue me" when you find her in her cell.

Note that overlap is only a potential problem if the plugins are loaded in the
order they are listed in the output.

Example:

# Show dialog overlaps between Lokken and SU:
tes3cmd overdial BT_Whitewolf_2_0.esm Suran_Underworld_2.5.esp
};

sub opts_overdial {
    $_[0] && do { die $OVERDIAL_USAGE; };
    getopts('1D') or die $OVERDIAL_USAGE;
}

my $COM_USAGE = q{Usage: tes3cmd common OPTIONS plugin1 plugin2

OPTIONS
 -D   turn on debug output

Prints the IDs of records that the 2 given plugins have in common.

Example:

# Show the records in common between my plugin and Morrowind.esm:
tes3cmd common myplugin.esp Morrowind.esm
};

sub opts_com {
    $_[0] && do { die $COM_USAGE; };
    getopts('D') or die $COM_USAGE;
}


my $DIFF_USAGE = q{Usage: tes3cmd diff OPTIONS plugin1 plugin2

OPTIONS
 -D   turn on debug output.
 -i   comma-delimited list of field names to ignore.

Prints a report on the differences between the two TES3 files.
A summary report with up to four sections is printed to standard output
that gives an overview of differences, as lists of record IDs:
 - objects in plugin1 that do not exist in plugin2
 - objects in plugin2 that do not exist in plugin1
 - objects in plugin1 that are equal in plugin2
 - objects in plugin1 that are different in plugin2
(Sections that would have no items are not printed).

When objects in plugin1 are different in plugin2, each of these objects
is printed in detail to a file "plugin1.diff" and "plugin2.diff", which
can then be compared textually using a tool such as WinMerge or Emacs'
ediff function.

To reduce a great deal of "uninteresting" differences when diffing savegames,
CELL.FRMR records are automatically ignored when the ModIndex is zero. (Note
that in this case, the ObjIndex appears to only be incremented by one).


Example:

# Print report on differences between 2 savegames:
tes3cmd diff save1000.ess save2000.ess > diff.out

# You can also use the -i switch to ignore further subfields in order to help
# reduce the amount of differences as in the following example.
# Report on differences, but ignore the subfields CREA.AIDT and CELL.ND3D:
tes3cmd diff -i crea.aidt,cell.nd3d testa0000.ess testb0000.ess > diff.out
};

sub opts_diff {
    $_[0] && do { die $DIFF_USAGE; };
    getopts('Di:') or die $DIFF_USAGE;
}


my $DUMP_USAGE = q{Usage: tes3cmd dump OPTIONS plugin...

OPTIONS
 -D        turn on debug output.
 -c regex  when dumping cells, only dump the matching objects in the cell.
 -i ids    only print out the records with ids matching the given comma-delimited
           list of regular expression patterns.
 -l        only list the ids of the records to be printed, instead of the entire record.
 -f file   file containing list of regexes to match, one per line.
 -F file   file containing list of regexes to not match, one per line.
 -m regex  only print records that match given regular expression.
 -M regex  only print records that do not match given regular expression.
 -n        do not print banner identifying the current plugin.
 -N        print record numbers (starting from first printed == 1).
 -R        print raw records, instead of as text, as an .esp including a TES3 header.
 -r        print raw records, instead of as text.
 -s string specify field separator string for single-line output.
 -t types  only print out the records matching the given comma-delimited
           list of record types.

Dumps the plugin to stdout in text form for easy perusal. For large plugins,
the output can be voluminous.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Examples:

# Dump all records from a plugin (this could generate a lot of output):
tes3cmd dump plugin.esp

# Dump all records with IDs matching "foo":
tes3cmd dump -i foo plugin.esp

# Dump all the CELL records from a plugin:
tes3cmd dump -t cell plugin.esp

# Dump all cells from bradhia_v1_4.esp containing NPC named: "Maeve Jaste"
tes3cmd dump -t cell -m "NAME:.*maeve.jaste" bradhia_v1_4.esp
};

my $blank_header = 'TES34          HEDR,    €?    tes3cmd                                                                                                                                                                                                                                                                                            ';


# return a dictionary of all the files found in the given directory.
# keys are lowercased for caseless file finding.
sub list_files {
    my($dir) = @_;
    my %files = ();
    if (opendir(DH, $dir)) {
	while (my $file = readdir(DH)) {
	    next if (($file eq '.') or ($file eq '..'));
	    $files{lc $file} = $file;
	}
	closedir(DH);
    } else {
	print qq{ERROR opening "$dir" ($!)\n};
    }
    return(\%files);
}

sub list_active {
    my($datadir) = @_;
    my $datafiles = list_files($datadir);
    my $mwfiles = list_files("$datadir/..");
    my $ini = "$datadir/../$mwfiles->{'morrowind.ini'}";
    my %active;
    if (open(INI, "<$ini")) {
	print qq{INI is: "$ini"\n} if (DBG);
	while (<INI>) {
	    if (/GameFile\d+=([^\r\n]*)/) {
		my $plugin = lc $1;
		if ($datafiles->{$plugin}) {
		    print qq{Found Gamefile: "$1"\n} if (DBG);
		    $active{$plugin} = $1;
		} else {
		    print qq{MISSING Gamefile: "$1"\n} if (DBG);
		}
	    }
	}
	close(INI);
    } else {
	print qq{Error opening "$ini" for input ($!)\n};
    }
    return(\%active);
}

# assuming the program is run somewhere under the Morrowind game directory, find the
# location of the "Data Files" directory by walking up the hierarchy.
sub find_datadir {
    my $dirlist = list_files(".");
    if ($dirlist->{"morrowind.esm"}) {
	return(".");
    }
    my $dir = Cwd::getcwd();
    print "DBG: checking for data dir in: $dir\n" if (DBG);
    while (($dir =~ m!\bmorrowind\b!i) and (-d $dir)) {
	my $datadir = list_files($dir)->{"data files"};
	if ($datadir) {
	    print "DBG: found datadir: $dir/$datadir\n" if (DBG);
	    return("$dir/$datadir");
	}
	my @parts = split(m![\\/]!, $dir);
	pop(@parts);
	$dir = join("/", @parts);
	print "DBG: checking for data dir in: $dir\n" if (DBG);
    }
    print qq{Can't find "Data Files" directory. Won't be able to find masters\n};
    return(undef);		# not running under morrowind directory
}


my @CELL_FLAGS = ([0x02, "Has_Water"],
		  [0x041, "Illegal_to_Sleep_Here"],
		  [0x80, "Behave_like_Exterior"]);

my %INFO_FUN = ('00' => "Reaction_Low",
		'01' => "Reaction_High",
		'02' => "Rank_Requirement",
		'03' => "Reputation",
		'04' => "Health_Percent",
		'05' => "PC_Reputation",
		'06' => "PC_Level",
		'07' => "PC_Health_Percent",
		'08' => "PC_Magicka",
		'09' => "PC_Fatigue",

		'10' => "PC_Strength",
		'11' => "PC_Block",
		'12' => "PC_Armorer",
		'13' => "PC_Medium_Armor",
		'14' => "PC_Heavy_Armor",
		'15' => "PC_Blunt_Weapon",
		'16' => "PC_Long_Blade",
		'17' => "PC_Axe",
		'18' => "PC_Spear",
		'19' => "PC_Athletics",

		'20' => "PC_Enchant",
		'21' => "PC_Destruction",
		'22' => "PC_Alteration",
		'23' => "PC_Illusion",
		'24' => "PC_Conjuration",
		'25' => "PC_Mysticism",
		'26' => "PC_Restoration",
		'27' => "PC_Alchemy",
		'28' => "PC_Unarmored",
		'29' => "PC_Security",

		'30' => "PC_Sneak",
		'31' => "PC_Acrobatics",
		'32' => "PC_Light_Armor",
		'33' => "PC_Short_Blade",
		'34' => "PC_Marksman",
		'35' => "PC_Mercantile",
		'36' => "PC_Speechcraft",
		'37' => "PC_Hand_To_Hand",
		'38' => "PC_Sex",
		'39' => "PC_Expelled",

		'40' => "PC_Common_Disease",
		'41' => "PC_Blight_Disease",
		'42' => "PC_Clothing_Modifier",
		'43' => "PC_Crime_Level",
		'44' => "Same_Sex",
		'45' => "Same_Race",
		'46' => "Same_Faction",
		'47' => "Faction_Rank_Difference",
		'48' => "Detected",
		'49' => "Alarmed",

		'50' => "Choice",
		'51' => "PC_Intelligence",
		'52' => "PC_Willpower",
		'53' => "PC_Agility",
		'54' => "PC_Speed",
		'55' => "PC_Endurance",
		'56' => "PC_Personality",
		'57' => "PC_Luck",
		'58' => "PC_Corprus",
		'59' => "Weather",

		'60' => "PC_Vampire",
		'61' => "Level",
		'62' => "Attacked",
		'63' => "Talked_To_PC",
		'64' => "PC_Health",
		'65' => "Creature_Target",
		'66' => "Friend_Hit",
		'67' => "Fight",
		'68' => "Hello",
		'69' => "Alarm",

		'70' => "Flee",
		'71' => "Should_Attack",
		'72' => "Werewolf",
		'73' => "Werewolf_Kills",

		'CX' => "Not_Class",
		'DX' => "Dead_Type",
		'FX' => "Not_Faction",
		'IX' => "Item_Type",
		'JX' => "Journal_Type",
		'LX' => "Not_Cell",
		'RX' => "Not_Race",
		'XX' => "Not_ID_Type",
		'fX' => "Global",
		'lX' => "PCGold",
		'sX' => "Variable_Compare",
	       );

my %INFO_SCVR_type =
    ('0' => "Nothing",
     '1' => "Function",
     '2' => "Global",
     '3' => "Local",
     '4' => "Journal",
     '5' => "Item",
     '6' => "Dead",
     '7' => "Not_ID",
     '8' => "Not_Faction",
     '9' => "Not_Class",
     'A' => "Not_Race",
     'B' => "Not_Cell",
     'C' => "Not_Local");

my %INFO_SCVR_cmp =
    ('0' => '=',
     '1' => '!=',
     '2' => '>',
     '3' => '>=',
     '4' => '<',
     '5' => '<=');

my %SEX = (0 => "Male", 1 => "Female", 0xFF => "None");
my %SPECIALIZATION = (0 => "Combat", 1 => "Magic", 2 => "Stealth");

my %SKILL = ( 0 => "Block",
	      1 => "Armorer",
	      2 => "MediumArmor",
	      3 => "HeavyArmor",
	      4 => "BluntWeapon",
	      5 => "LongBlade",
	      6 => "Axe",
	      7 => "Spear",
	      8 => "Athletics",
	      9 => "Enchant",
	     10 => "Destruction",
	     11 => "Alteration",
	     12 => "Illusion",
	     13 => "Conjuration",
	     14 => "Mysticism",
	     15 => "Restoration",
	     16 => "Alchemy",
	     17 => "Unarmored",
	     18 => "Security",
	     19 => "Sneak",
	     20 => "Acrobatics",
	     21 => "LightArmor",
	     22 => "ShortBlade",
	     23 => "Marksman",
	     24 => "Mercantile",
	     25 => "SpeechCraft",
	     26 => "HandToHand",
	    255 => "None");

my %ATTRIBUTE = (0 => "Strength",
		 1 => "Intelligence",
		 2 => "Willpower",
		 3 => "Agility",
		 4 => "Speed",
		 5 => "Endurance",
		 6 => "Personality",
		 7 => "Luck");

my @AUTOCALC_FLAGS = ([0x00001, "Weapon"],
		      [0x00002, "Armor"],
		      [0x00004, "Clothing"],
		      [0x00008, "Books"],
		      [0x00010, "Ingredient"],
		      [0x00020, "Picks"],
		      [0x00040, "Probes"],
		      [0x00080, "Lights"],
		      [0x00100, "Apparatus"],
		      [0x00200, "Repair"],
		      [0x00400, "Misc"],
		      [0x00800, "Spells"],
		      [0x01000, "Magic_Items"],
		      [0x02000, "Potions"],
		      [0x04000, "Training"],
		      [0x08000, "Spellmaking"],
		      [0x10000, "Enchanting"],
		      [0x20000, "Repair_Item"]);

my %DIAL_TYPE = (0 => "Topic",
		 1 => "Voice",
		 2 => "Greeting",
		 3 => "Persuasion",
		 4 => "Journal");

my %SPLM_TYPE = (1 => "Spell", 2 => "Enchantment");

my %ENCHANT_TYPE = (0 => "Cast_Once",
		    1 => "Cast_on_Strike",
		    2 => "Cast_when_Used",
		    3 => "Constant_Effect");

my %RANGE_TYPE = (0 => "Self", 1 => "Touch", 2 => "Target");

my @MGEF_FLAGS = ([0x0200, "Spellmaking"],
		  [0x0400, "Enchanting"],
		  [0x0800, "Negative"]);

my %MAGIC_SCHOOL = (0 => "Alteration",
		    1 => "Conjuration",
		    2 => "Destruction",
		    3 => "Illusion",
		    4 => "Mysticism",
		    5 => "Restoration");

my %SPEL_TYPE = (0 => "Spell",
		 1 => "Ability",
		 2 => "Blight",
		 3 => "Disease",
		 4 => "Curse",
		 5 => "Power");

my @SPEL_FLAGS = ([0x0001, "AutoCalc"],
		  [0x0002, "PC_Start"],
		  [0x0004, "Always_Succeeds"]);

my %WEAPON_TYPE = (0 => "ShortBladeOneHand",
		   1 => "LongBladeOneHand",
		   2 => "LongBladeTwoClose",
		   3 => "BluntOneHand",
		   4 => "BluntTwoClose",
		   5 => "BluntTwoWide",
		   6 => "SpearTwoWide",
		   7 => "AxeOneHand",
		   8 => "AxeTwoHand",
		   9 => "MarksmanBow",
		   10 => "MarksmanCrossbow",
		   11 => "MarksmanThrown",
		   12 => "Arrow",
		   13 => "Bolt");

my %WEAPON_FLAGS = (1 => "[Ignores_Normal_Weapon_Resistance]");

my @CONTAINER_FLAGS = ([0x0001, "Organic"],
		       [0x0002, "Respawns,_Organic_only"],
		       [0x0008, "Default"]);

my @CREATURE_FLAGS = ([0x0001, "Biped"],
		      [0x0002, "Respawn"],
		      [0x0004, "Weapon_and_shield"],
		      [0x0008, "Movement:None"],
		      [0x0010, "Swims"],
		      [0x0020, "Flies"],
		      [0x0040, "Walks"],
		      [0x0080, "Essential"],
		      [0x0400, "Skeleton_Blood"],
		      [0x0800, "Metal_Blood"]);

my %ARMOR_TYPE = (0 => "Helmet",
		  1 => "Cuirass",
		  2 => "Left_Pauldron",
		  3 => "Right_Pauldron",
		  4 => "Greaves",
		  5 => "Boots",
		  6 => "Left_Gauntlet",
		  7 => "Right_Gauntlet",
		  8 => "Shield",
		  9 => "Left_Bracer",
		  10 => "Right_Bracer");

my %APPARATUS_TYPE = (0 => "Mortar_and_Pestle",
		      1 => "Alembic",
		      2 => "Calcinator",
		      3 => "Retort");

my %ARMOR_INDEX = (0 => "Head",
		   1 => "Hair",
		   2 => "Neck",
		   3 => "Cuirass",
		   4 => "Groin",
		   5 => "Skirt",
		   6 => "Right_Hand",
		   7 => "Left_Hand",
		   8 => "Right_Wrist",
		   9 => "Left_Wrist",
		   10 => "Shield",
		   11 => "Right_Forearm",
		   12 => "Left_Forearm",
		   13 => "Right_Upper_Arm",
		   14 => "Left_Upper_Arm",
		   15 => "Right_Foot",
		   16 => "Left_Foot",
		   17 => "Right_Ankle",
		   18 => "Left_Ankle",
		   19 => "Right_Knee",
		   20 => "Left_Knee",
		   21 => "Right_Upper_Leg",
		   22 => "Left_Upper_Leg",
		   23 => "Right_Pauldron",
		   24 => "Left_Pauldron",
		   25 => "Weapon",
		   26 => "Tail");

my %CTDT_TYPE = (0 => "Pants",
		 1 => "Shoes",
		 2 => "Shirt",
		 3 => "Belt",
		 4 => "Robe",
		 5 => "Right_Glove",
		 6 => "Left_Glove",
		 7 => "Skirt",
		 8 => "Ring",
		 9 => "Amulet");

my @NPC_FLAGS = ([0x0001, "Female"],
		 [0x0002, "Essential"],
		 [0x0004, "Respawn"],
		 [0x0010, "Autocalc"],
		 [0x0400, "Blood_Skel"],
		 [0x0800, "Blood_Metal"]);

my %LEVI_DATA = (1 => "Calc from all levels <= PC level",
		 2 => "Calc for each item");

my @AIDT_FLAGS = ([0x00001, "Weapon"],
		  [0x00002, "Armor"],
		  [0x00004, "Clothing"],
		  [0x00008, "Books"],
		  [0x00010, "Ingredient"],
		  [0x00020, "Picks"],
		  [0x00040, "Probes"],
		  [0x00080, "Lights"],
		  [0x00100, "Apparatus"],
		  [0x00200, "Repair"],
		  [0x00400, "Misc"],
		  [0x00800, "Spells"],
		  [0x01000, "Magic_Items"],
		  [0x02000, "Potions"],
		  [0x04000, "Training"],
		  [0x08000, "Spellmaking"],
		  [0x10000, "Enchanting"],
		  [0x20000, "Repair_Item"]);

my @LHDT_FLAGS = ([0x0001, "Dynamic"],
		  [0x0002, "Can_Carry"],
		  [0x0004, "Negative"],
		  [0x0008, "Flicker"],
		  [0x0010, "Fire"],
		  [0x0020, "Off_Default"],
		  [0x0040, "Flicker_Slow"],
		  [0x0080, "Pulse"],
		  [0x0100, "Pulse_Slow"]);

my @RADT_FLAGS = ([0x01, "Playable"], [0x02, "Beast_Race"]);

my %SPELL_EFFECT = ('0' => "Water_Breathing",
		    '1' => "Swift_Swim",
		    '2' => "Water_Walking",
		    '3' => "Shield",
		    '4' => "Fire_Shield",
		    '5' => "Lightning_Shield",
		    '6' => "Frost_Shield",
		    '7' => "Burden",
		    '8' => "Feather",
		    '9' => "Jump",
		    '10' => "Levitate",
		    '11' => "Slowfall",
		    '12' => "Lock",
		    '13' => "Open",
		    '14' => "Fire_Damage",
		    '15' => "Shock_Damage",
		    '16' => "Frost_Damage",
		    '17' => "Drain_Attribute",
		    '18' => "Drain_Health",
		    '19' => "Drain_Magicka",
		    '20' => "Drain_Fatigue",
		    '21' => "Drain_Skill",
		    '22' => "Damage_Attribute",
		    '23' => "Damage_Health",
		    '24' => "Damage_Magicka",
		    '25' => "Damage_Fatigue",
		    '26' => "Damage_Skill",
		    '27' => "Poison",
		    '28' => "Weakness_to_Fire",
		    '29' => "Weakness_to_Frost",
		    '30' => "Weakness_to_Shock",
		    '31' => "Weakness_to_Magicka",
		    '32' => "Weakness_to_Common_Disease",
		    '33' => "Weakness_to_Blight_Disease",
		    '34' => "Weakness_to_Corprus_Disease",
		    '35' => "Weakness_to_Poison",
		    '36' => "Weakness_to_Normal_Weapons",
		    '37' => "Disintegrate_Weapon",
		    '38' => "Disintegrate_Armor",
		    '39' => "Invisibility",
		    '40' => "Chameleon",
		    '41' => "Light",
		    '42' => "Sanctuary",
		    '43' => "Night_Eye",
		    '44' => "Charm",
		    '45' => "Paralyze",
		    '46' => "Silence",
		    '47' => "Blind",
		    '48' => "Sound",
		    '49' => "Calm_Humanoid",
		    '50' => "Calm_Creature",
		    '51' => "Frenzy_Humanoid",
		    '52' => "Frenzy_Creature",
		    '53' => "Demoralize_Humanoid",
		    '54' => "Demoralize_Creature",
		    '55' => "Rally_Humanoid",
		    '56' => "Rally_Creature",
		    '57' => "Dispel",
		    '58' => "Soultrap",
		    '59' => "Telekinesis",
		    '60' => "Mark",
		    '61' => "Recall",
		    '62' => "Divine_Intervention",
		    '63' => "Almsivi_Intervention",
		    '64' => "Detect_Animal",
		    '65' => "Detect_Enchantment",
		    '66' => "Detect_Key",
		    '67' => "Spell_Absorption",
		    '68' => "Reflect",
		    '69' => "Cure_Common_Disease",
		    '70' => "Cure_Blight_Disease",
		    '71' => "Cure_Corprus_Disease",
		    '72' => "Cure_Poison",
		    '73' => "Cure_Paralyzation",
		    '74' => "Restore_Attribute",
		    '75' => "Restore_Health",
		    '76' => "Restore_Magicka",
		    '77' => "Restore_Fatigue",
		    '78' => "Restore_Skill",
		    '79' => "Fortify_Attribute",
		    '80' => "Fortify_Health",
		    '81' => "Fortify_Magicka",
		    '82' => "Fortify_Fatigue",
		    '83' => "Fortify_Skill",
		    '84' => "Fortify_Maximum_Magicka",
		    '85' => "Absorb_Attribute",
		    '86' => "Absorb_Health",
		    '87' => "Absorb_Magicka",
		    '88' => "Absorb_Fatigue",
		    '89' => "Absorb_Skill",
		    '90' => "Resist_Fire",
		    '91' => "Resist_Frost",
		    '92' => "Resist_Shock",
		    '93' => "Resist_Magicka",
		    '94' => "Resist_Common_Disease",
		    '95' => "Resist_Blight_Disease",
		    '96' => "Resist_Corprus_Disease",
		    '97' => "Resist_Poison",
		    '98' => "Resist_Normal_Weapons",
		    '99' => "Resist_Paralysis",
		    '100' => "Remove_Curse",
		    '101' => "Turn_Undead",
		    '102' => "Summon_Scamp",
		    '103' => "Summon_Clannfear",
		    '104' => "Summon_Daedroth",
		    '105' => "Summon_Dremora",
		    '106' => "Summon_Ancestral_Ghost",
		    '107' => "Summon_Skeltal_Minion",
		    '108' => "Summon_Bonewalker",
		    '109' => "Summon_Greater_Bonewalker",
		    '110' => "Summon_Bonelord",
		    '111' => "Summon_Winged_Twilight",
		    '112' => "Summon_Hunger",
		    '113' => "Summon_Golden_Saint",
		    '114' => "Summon_Flame_Atronach",
		    '115' => "Summon_Frost_Atronach",
		    '116' => "Summon_Storm_Atronach",
		    '117' => "Fortify_Attack",
		    '118' => "Command_Creature",
		    '119' => "Command_Humanoid",
		    '120' => "Bound_Dagger",
		    '121' => "Bound_Longsword",
		    '122' => "Bound_Mace",
		    '123' => "Bound_Battle_Axe",
		    '124' => "Bound_Spear",
		    '125' => "Bound_Longbow",
		    '126' => "EXTRA_SPELL",
		    '127' => "Bound_Cuirass",
		    '128' => "Bound_Helm",
		    '129' => "Bound_Boots",
		    '130' => "Bound_Shield",
		    '131' => "Bound_Gloves",
		    '132' => "Corprus",
		    '133' => "Vampirism",
		    '134' => "Summon_Centurion_Spider",
		    '135' => "Sun_Damage",
		    '136' => "Stunted_Magicka",
		    '137' => "Summon_Fabricant",
		    '138' => "Call_Wolf",
		    '139' => "Call_Bear",
		    '140' => "Summon_Bonewolf",
		    '141' => "sEffectSummonCreature04",
		    '142' => "sEffectSummonCreature05",
		   );

my %BYDT_PART = ('0' => "Head",
		 '1' => "Hair",
		 '2' => "Neck",
		 '3' => "Chest",
		 '4' => "Groin",
		 '5' => "Hand",
		 '6' => "Wrist",
		 '7' => "Forearm",
		 '8' => "Upperarm",
		 '9' => "Foot",
		 '10' => "Ankle",
		 '11' => "Knee",
		 '12' => "Upperleg",
		 '13' => "Clavicle",
		 '14' => "Tail");

my %BYDT_FLAGS = ('0' => "None", '1' => "Female", '2' => "Playable");

my %BYDT_PTYP = ('0' => "Skin", "1" => "Clothing", "2" => "Armor");

my @FACT_FLAGS = ([0x0001, "Hidden_From_Player"]);

my @CREA_TYPE = qw(Creature Daedra Undead Humanoid);

my @SNDG_DATA = ("Left_Foot", "Right_Foot", "Swim_Left", "Swim_Right", "Moan", "Roar", "Scream", "Land");

sub indent_result {
    my($str) = @_;
    $str =~ tr/\r//d;
    $str =~ s/\n/\n\t\t/g;
    return("\t\t$str");
}

sub dbg_ulong {
    my($long) = @_;
    my $longstr = pack("L", $long);
    #, unpack("l", $longstr)
    sprintf qq{[%s (%d)  (%d %d) (%d %d %d %d)]},
	unpack("H*", $longstr), $long, unpack("S2", $longstr), unpack("C4", $longstr);
}

sub decode_flags {
    my($flags, $flagdefs) = @_;
    my @list = ();
    foreach my $ref (@{$flagdefs}) {
	my($val, $name) = @$ref;
	push(@list, $name) if ($flags & $val);
    }
    my $flagstr = sprintf "0x%04x", $flags;
    return("$flagstr (" . join(", ", @list) . ")");
}

sub dump_lookup {
    my($key, $hashref) = @_;
    return($hashref->{$key} || $key . "???");
}

my $NREC;

my %DECODE = ();
my %ENCODE = ();
my %RD = ();			# TBD switch to using the info from DECODE and get rid of RD
sub compile_def {
    my(@def) = @_;
    my $format = "";
    foreach my $ref (@def) {
	$format .= $ref->[1];
    }
    return($format);
}
sub default_decoder {
    my(@def) = @_;
    my $cdef = compile_def(@def);
    my $decoder = sub {
	my($buff) = @_;
	my %hr;
	my %idx;
	my $index = 0;
	my @keys = map { $_->[0]; } @def;
        my @vals = unpack($cdef, $buff);
	foreach my $val (@vals) {
	    my $key = shift(@keys);
	    while (ref($key) eq 'ARRAY') {
	    	unshift(@keys, @$key);
		$key = shift(@keys);
	    }
	    my $n = 2;
	    while (exists $hr{$key}) {
	    	$key =~ s/_\d+$/_/;
		$key .= $n++;
	    }
	    $hr{$key} = $val;
	    $idx{$key} = $index++;
	}
	return(\%hr, \%idx);
    };
    return($decoder);
};
sub default_encoder {
    my(@def) = @_;
    my $cdef = compile_def(@def);
    my $encoder = sub {
	my($hr, $idx) = @_;
	my @rec = ();
	while (my($key, $val) = each %$hr) {
	    $rec[$idx->{$key}] = $val;
	}
	#warn qq{cdef=="$cdef"    rec==\n}, Dumper([@rec]), "\n";
	return(pack($cdef, @rec));
    };
    return($encoder);
};
sub default_codec {
    my($type, @def) = @_;
    $DECODE{$type} = default_decoder(@def);
    $ENCODE{$type} = default_encoder(@def);
    $RD{$type} = compile_def(@def); # for transitional code
}
default_codec('TES3.HEDR', (["Version", "f"],
			    ["Unknown", "L"],
			    ["Author", "Z32"],
			    ["Description", "Z256"],
			    ["N-Records", "L"]));
default_codec('TES3.MAST', (["Master", "Z*"]));

# custom codec for TES3.DATA
$DECODE{'TES3.DATA'} = sub {
    my($buff) = @_;
    my($l1, $l2) = unpack("L2", $buff);
    return({ Length => $l1 + ($l2 << 32) },
	   {});			# indices not needed by custom encoder
};
$ENCODE{'TES3.DATA'} = sub {
    my($hr, $idx) = @_;
    my $len = $hr->{Length};
    my $l1 = $len & 0xffffffff;
    my $l2 = $len >> 32;
    return(pack("L2", $l1, $l2));
};

default_codec('ALCH.ALDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Autocalc", "L"]));
default_codec('APPA.AADT', (["Type", "L"],
			    ["Quality", "f"],
			    ["Weight", "f"],
			    ["Value", "L"]));
default_codec('ARMO.AODT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "L"],
			    ["Health", "L"],
			    ["Enchant_Points", "L"],
			    ["Armor_Rating", "L"]));
default_codec('ARMO.INDX', (["Index", "C"]));
default_codec('BODY.BYDT', (["Body_Part", "C"],
			    ["Vampire", "C"],
			    ["Flags", "C"],
			    ["Part_Type", "C"]));
default_codec('BOOK.BKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Scroll", "L"],
			    ["Skill", "L"],
			    ["Enchant_Points", "L"]));
default_codec('CELL.AMBI', (["Ambient_Color", "l"],
			    ["Sunlight_Color", "l"],
			    ["Fog_Color", "l"],
			    ["Fog_Density", "f"]));
default_codec('CELL.CSTN', (["Target", "Z*"])); # guessing this is: "cast spell target name"

# custom codec for CELL_DATA
$DECODE{'CELL.DATA'} = sub {
    my($buff) = @_;
    if (length($buff) == 24) {
	my($x, $y, $z, $xrot, $yrot, $zrot) = unpack("f6", $buff);
	return({ X => $x, Y => $y, Z => $z,
		 X_angle => $xrot, Y_angle => $yrot, Z_angle => $zrot },
	       {});		# indices not needed by custom encoder
    } else {
	my($flags, $fog) = unpack("Lx[L]f", $buff);
	if ($flags & 0x01) { 	# Interior
	    return({ Flags => $flags, Fog_Density => $fog },
		   {});		# indices not needed by custom encoder
	} else {		# Exterior
	    my($x, $y) = unpack("x[L]ll", $buff);
	    return({ Flags => $flags, X => $x, Y => $y },
		   {});		# indices not needed by custom encoder
	}
    }
};
$ENCODE{'CELL.DATA'} = sub {
    my($hr, $idx) = @_;
    if (exists $hr->{Flags}) {
	if ($hr->{Flags} & 0x01) { # Interior
	    return(pack("Lx[L]f", $hr->{Flags}, $hr->{Fog_Density}));
	} else {		     # Exterior
	    return(pack("Lll", $hr->{Flags}, $hr->{X}, $hr->{Y}));
	}
    } else {
	return(pack("f6", $hr->{X}, $hr->{Y}, $hr->{Z},
		    $hr->{X_angle}, $hr->{Y_angle}, $hr->{Z_angle}));
    }
};

default_codec('CELL.FRMR', (["ObjInd", "Sx[C]"],
			    #["Unknown", "C"],
			    ["ModInd", "C"]));
default_codec('CELL.NAM5', (["R", "C"],
			    ["G", "C"],
			    ["B", "C"])); # Map Color
default_codec('CELL.NAM9', (["Owner", "L"]));
default_codec('CLAS.CLDT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Minor_Skill_1", "Major_Skill_1") x 5], "(L2)5"],
			    ["Flags", "L"],
			    ["AutoCalc", "L"]));
default_codec('CLOT.CTDT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "S"],
			    ["Enchant_Points", "S"]));
default_codec('CLOT.INDX', (["Index", "C"]));
default_codec('CONT.CNDT', (["Weight", "f"]));
default_codec('CONT.FLAG', (["Container_Flags", "L"]));
default_codec('CREA.AI_W', (["Distance", "S"],
			    ["Duration", "C"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 10], "C10"]));
#default_codec('CREA.AIDT', ([[("AI_1") x 12], "C12"]));
default_codec('CREA.AIDT', (["Hello", "C"],
			    ["Unknown", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    [[("Unknown_1") x 3], "C3"],
			    ["Flags", "L"]));
default_codec('CREA.FLAG', (["Flags", "L"]));
default_codec('CREA.NPDT', (["Type", "L"],
			    ["Lev", "L"],
			    ["Str", "L"],
			    ["Int", "L"],
			    ["Wil", "L"],
			    ["Agi", "L"],
			    ["Spd", "L"],
			    ["End", "L"],
			    ["Per", "L"],
			    ["Lck", "L"],
			    ["Health", "L"],
			    ["Spell_Points", "L"],
			    ["Fatigue", "L"],
			    ["Soul", "L"],
			    ["Combat", "L"],
			    ["Magic", "L"],
			    ["Stealth", "L"],
			    ["Attack_1_Min", "L"],
			    ["Attack_1_Max", "L"],
			    ["Attack_2_Min", "L"],
			    ["Attack_2_Max", "L"],
			    ["Attack_3_Min", "L"],
			    ["Attack_3_Max", "L"],
			    ["Gold", "L"]));
default_codec('DIAL.DATA', (["Type", "C"]));
default_codec('ENCH.ENDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Charge", "L"],
			    ["Autocalc", "L"]));
default_codec('ENCH.ENAM', (["Spell_Effect", "S"],
			    ["Skill", "C"],
			    ["Attribute", "C"],
			    ["Range", "L"],
			    ["Area", "L"],
			    ["Duration", "L"],
			    ["MagMin", "L"],
			    ["MagMax", "L"]));
default_codec('FACT.FADT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    [[("At1_1", "At2_1", "Sk1_1", "Sk2_1", "Fact_1") x 10], "(L5)10"],
			    [[("Sk_1") x 6], "L6"],
			    ["Unknown", "L"],
			    ["Flags", "L"]));
#			  foreach my $rd (unpack("(a20)10", $rankdata)) {
#			      my($at1, $at2, $sk1, $sk2, $fact) = unpack("L5", $rd);
#			      push(@results, sprintf "\t\tAttr_1: %3d  Attr_2: %3d  Skill_1: %3d  Skill_2: %3d  Fact: %3d",
#				  $at1, $at2, $sk1, $sk2, $fact);
#			  }
#			  join("\n", @results);

default_codec('GLOB.FNAM', (["VarType", "a"]));
default_codec('GMST.NAME', (["Name", "a*"]));
default_codec('INFO.ACDT', (["Actor_Data", "Z*"])); # (only in .ess)
default_codec('INFO.INAM', (["Name", "Z*"]));
default_codec('INFO.DATA', (#["Unknown", "L"],
			    ["Disposition", "x[L]L"],
			    ["Rank", "C"],
			    ["Sex", "C"],
			    ["PCRank", "C"]));
default_codec('INFO.ANAM', (["Cell", "Z*"]));
default_codec('INFO.BNAM', (["Result", "Z*"]));
default_codec('INFO.CNAM', (["Class", "Z*"]));
default_codec('INFO.DNAM', (["PC_Faction", "Z*"]));
default_codec('INFO.FNAM', (["Faction", "Z*"]));
default_codec('INFO.NAME', (["Response", "Z*"]));
default_codec('INFO.NNAM', (["Next_ID", "Z*"]));
default_codec('INFO.ONAM', (["Actor", "Z*"]));
default_codec('INFO.PNAM', (["Prev_ID", "Z*"]));
default_codec('INFO.RNAM', (["Race", "Z*"]));
default_codec('INFO.QSTN', (["Quest_Name", "C"]));
default_codec('INFO.QSTF', (["Quest_Finished", "C"]));
default_codec('INFO.QSTR', (["Quest_Restart", "C"]));
default_codec('INFO.SCVR', (["Index", "a"],
			    ["Type", "a"],
			    ["Function", "a2"],
			    ["Comparison", "a"],
			    ["Name", "Z*"]));
default_codec('INGR.IRDT', (["Weight", "f"],
			    ["Value", "L"],
			    [[("Effect_1") x 4], "l4"],
			    [[("Skill_1") x 4], "l4"],
			    [[("Attribute_1") x 4], "l4"]));
default_codec('LAND.INTV', (["X", "l"],
			    ["Y", "l"]));
default_codec('LEVC.DATA', (["List_Data", "L"]));
default_codec('LEVC.INTV', (["Level", "S"]));
default_codec('LEVC.NNAM', (["Chance_None", "C"]));
default_codec('LEVI.DATA', (["List_Data", "L"]));
default_codec('LEVI.INTV', (["Level", "S"]));
default_codec('LEVI.INAM', (["Name", "Z*"]));
default_codec('LEVI.NNAM', (["Chance_None", "C"]));
default_codec('LIGH.LHDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Time", "L"],
			    ["Radius", "L"],
			    ["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"],
			    ["Unknown", "C"],
			    ["Flags", "L"]));
default_codec('LOCK.LKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('LTEX.DATA', (["Data", "Z*"]));
default_codec('MGEF.MEDT', (["School", "L"],
			    ["Base_Cost", "f"],
			    ["Flags", "L"],
			    ["Red", "L"],
			    ["Green", "L"],
			    ["Blue", "L"],
			    ["Speed", "f"],
			    ["Size", "f"],
			    ["SizeCap", "f"]));
default_codec('MISC.MCDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Unknown", "L"]));
default_codec('NPC_.CNDT', (["Data", "Z*"]));
default_codec('NPC_.FLAG', (["Flags", "L"]));
default_codec('NPC_.AIDT', (["Hello", "C"],
			    ["Unknown", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    [[("Unknown_1") x 3], "C3"],
			    ["Flags", "L"]));
default_codec('NPC_.AI_W', (["Distance", "S"],
			    ["Duration", "S"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 8], "C8"],
			    ["Unknown", "C"]));

$DECODE{'NPC_.NPDT'} = sub {
    my($buff) = @_;
    my %hr;
    my $len = length($buff);
    if ($len == 12) {
	my($lev, $disp, $fact, $rank, $gold) = unpack("SC3x[C3]L", $_[0]);
	return({ Level => $lev, Disposition => $disp, Faction => $fact, Rank => $rank, Gold => $gold },
	       {});
    } elsif ($len == 52) {
	my $i = 0;
	my %hr;
	foreach my $skill_level (unpack("x[SC8]C27", $buff)) {
	    $hr{$SKILL{$i++}} = $skill_level;
	}
	($hr{Level}, $hr{Str}, $hr{Int}, $hr{Wil}, $hr{Agi}, $hr{Spd}, $hr{End},
	 $hr{Per}, $hr{Lck}, $hr{Rep}, $hr{Health}, $hr{Magicka}, $hr{Fatigue},
	 $hr{Disposition}, $hr{Faction}, $hr{Rank}, $hr{Gold}) = unpack("SC8x[C27]CSSSCCCCxCL", $buff);
	return(\%hr, {});
    } else {
	warn "BAD NPC_.NPDT length ($len) is not 12 or 52!\n";
    }
};
$ENCODE{'NPC_.NPDT'} = sub {
    my($hr, $idx) = @_;
    if (exists $hr->{Magicka}) {
	return(pack("SC8C27CSSSCCCCxCL",
		    $hr->{Level}, $hr->{Str}, $hr->{Int}, $hr->{Wil}, $hr->{Agi},
		    $hr->{Spd}, $hr->{End}, $hr->{Per}, $hr->{Lck},
		    $hr->{"Block"}, $hr->{"Armorer"}, $hr->{"MediumArmor"}, $hr->{"HeavyArmor"},
		    $hr->{"BluntWeapon"}, $hr->{"LongBlade"}, $hr->{"Axe"}, $hr->{"Spear"},
		    $hr->{"Athletics"}, $hr->{"Enchant"}, $hr->{"Destruction"}, $hr->{"Alteration"},
		    $hr->{"Illusion"}, $hr->{"Conjuration"}, $hr->{"Mysticism"}, $hr->{"Restoration"},
		    $hr->{"Alchemy"}, $hr->{"Unarmored"}, $hr->{"Security"}, $hr->{"Sneak"},
		    $hr->{"Acrobatics"}, $hr->{"LightArmor"}, $hr->{"ShortBlade"}, $hr->{"Marksman"},
		    $hr->{"Mercantile"}, $hr->{"SpeechCraft"}, $hr->{"HandToHand"},
		    $hr->{Rep}, $hr->{Health}, $hr->{Magicka}, $hr->{Fatigue},
		    $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold}));
    } else {
	return(pack("SC3x[C3]L", $hr->{Level}, $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold}));
    }
};

#     "PCDT.SNAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.ENAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.FNAM" => $TOSTR_UNKNOWN, # .ess

default_codec('PROB.PBDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('QUES.DATA', (["Info_ID", "Z*"])); # only in .ess (relates back to Actor in INFO)
default_codec('RACE.RADT', ([[("Skill_1", "Bonus_1") x 7]],
			    [[("Attr_Male_1", "Attr_Female_1") x 8]],
			    ["Male_Height", "f"],
			    ["Female_Height", "f"],
			    ["Male_Weight", "f"],
			    ["Female_Weight", "f"],
			    ["Flags", "L"]));
default_codec('REGN.WEAT', (["Clear", "C"],
			    ["Cloudy", "C"],
			    ["Foggy", "C"],
			    ["Overcast", "C"],
			    ["Rain", "C"],
			    ["Thunder", "C"],
			    ["Ash", "C"],
			    ["Blight", "C"]));
default_codec('REGN.CNAM', (["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"]));
default_codec('REGN.SNAM', (["Sound_Name", "Z32"],
			    ["Chance", "C"]));
default_codec('REGN.WNAM', (["Name", "L"]));
default_codec('REPA.RIDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Uses", "L"],
			    ["Quality", "f"]));
default_codec('SCPT.RNAM', (["Unknown", "L"]));
default_codec('SCPT.SCDT', (["Bytecode", "H*"]));
default_codec('SCPT.SCHD', (["Name", "Z32"],
			    ["Num_Shorts", "L"],
			    ["Num_Longs", "L"],
			    ["Num_Floats", "L"],
			    ["Data_Size", "L"],
			    ["Long_Var_Size", "L"]));
default_codec('SCPT.SCVR', (["Variables", "a*"]));
default_codec('SCPT.SCTX', (["Script", "Z*"]));
default_codec('SKIL.SKDT', (["Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Use_Values_1") x 4], "f4"]));
default_codec('SNDG.DATA', (["Data", "L"]));
default_codec('SPEL.SPDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Flags", "L"]));
default_codec('SPLM.NAME', (["Name", "L"]));
default_codec('SPLM.SPDT', (["Type", "L"],
			    ["Name", "Z40"],
			    [[("Long_1") x 2, "L2"]],
			    ["Caster", "Z32"],
			    ["Item", "Z*"]));
default_codec('SPLM.NPDT', (["Name", "Z40"],
			    ["Magnitude", "l"],
			    [[("Long_1") x 3], "l3"]));
default_codec('SPLM.XNAM', (["Name", "L"]));
default_codec('SPLM.TNAM', (["Target", "Z*"]));
default_codec('SOUN.DATA', (["Volume", "C"],
			    ["MinRange", "C"],
			    ["MaxRange", "C"]));
default_codec('SSCR.DATA', (["Name", "Z*"]));
default_codec('STLN.ONAM', (["Name", "Z*"]));
default_codec('WEAP.WPDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Type", "S"],
			    ["Health", "S"],
			    ["Speed", "f"],
			    ["Reach", "f"],
			    ["Enchant_Points", "S"],
			    ["Chop_Min", "C"],
			    ["Chop_Max", "C"],
			    ["Slash_Min", "C"],
			    ["Slash_Max", "C"],
			    ["Thrust_Min", "C"],
			    ["Thrust_Max", "C"],
			    ["Flags", "L"]));
default_codec('VFXM.VNAM', ([[("Long_1") x 6], "L6"],
			    ["Short", "S"],
			    ["Unknown", "H22"],
			    ["Name_2", "Z36"],
			    ["Name_3", "Z68"]));
#default_codec('DELE', (["DELETED"]));
default_codec('DODT', (["X", "f"],
		       ["Y", "f"],
		       ["Z", "f"],
		       ["Angle_X", "f"],
		       ["Angle_Y", "f"],
		       ["Angle_Z", "f"]));
default_codec('FLAG', (["Flags", "L"]));
default_codec('NPCO', (["Count", "l"],
		       ["Name", "a32"]));
default_codec('XCHG', (["Enchant_Charge", "L"]));
default_codec('XHLT', (["Health", "L"]));
default_codec('XSCL', (["Scale", "f"]));
default_codec('XSOL', (["Soul", "Z*"]));
default_codec('WIDX', (["Equipped_Index", "l"],
		       ["Ammo_Flag", "l"]));
default_codec('SLCS', (["Shorts", "L"],
		       ["Longs", "L"],
		       ["Floats", "L"]));

$DECODE{'SLSD'} = sub {
    my($buff) = @_;
    my $i = 1;
    my %hr;
    foreach (unpack("s*", $buff)) {
        $hr{$i} = $_;
    }
    return(\%hr, {});
};
$ENCODE{'SLSD'} = sub {
    my($hr, $idx) = @_;
    my @vals;
    foreach my $key (sort { $a <=> $b } keys %$hr) { unshift(@vals, $key); }
    return(pack("s*", @vals));
};

$DECODE{'SLLD'} = sub {
    my($buff) = @_;
    my $i = 1;
    my %hr;
    foreach (unpack("l*", $buff)) { $hr{$i} = $_; }
    return(\%hr, {});
};
$ENCODE{'SLLD'} = sub {
    my($hr, $idx) = @_;
    my @vals;
    foreach my $key (sort { $a <=> $b } keys %$hr) { unshift(@vals, $key); }
    return(pack("l*", @vals));
};

$DECODE{'SLFD'} = sub {
    my($buff) = @_;
    my $i = 1;
    my %hr;
    foreach (unpack("f*", $buff)) { $hr{$i} = $_; }
    return(\%hr, {});
};
$ENCODE{'SLFD'} = sub {
    my($hr, $idx) = @_;
    my @vals;
    foreach my $key (sort { $a <=> $b } keys %$hr) { unshift(@vals, $key); }
    return(pack("f*", @vals));
};

$DECODE{"SPEL.ENAM"} = $DECODE{"ENCH.ENAM"};
$ENCODE{"SPEL.ENAM"} = $ENCODE{"ENCH.ENAM"};

default_codec('DELE');

# subrecords that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $DECODE{$_} = sub{ return({ IntVal => unpack("l", $_[0]) }, {}); };
    $ENCODE{$_} = sub{ pack("l", $_[0]->{IntVal} );
    };
}

# subrecords that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX)) {
    $DECODE{$_} = sub{ return({ IntVal => unpack("L", $_[0]) }, {}); };
    $ENCODE{$_} = sub{ pack("L", $_[0]->{IntVal} ); };
}

# subrecords that decode as 32-bit floats:
foreach (qw(FLTV WHGT)) {
    $DECODE{$_} = sub{ return({ FloatVal => unpack("f", $_[0]) }, {}); };
    $ENCODE{$_} = sub{ pack("f", $_[0]->{FloatVal} ); };
}

# subrecords that decode as variable length Z-strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FNAM
HSND HVFX ITEX KNAM LSTN MNAM MODL NAME NPCS PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TNAM WNAM)) {
    $DECODE{$_} = sub{ return({ String => unpack("Z*", $_[0]) }, {}); };
    $ENCODE{$_} = sub{ pack("Z*", $_[0]->{String} ); };
}

my $TOSTR_UNKNOWN =
    sub { my $buff = $_[0];
	  sprintf qq{len:%d  hex:%s  str:"%s"}, length($buff),
	      unpack("H*", $buff), substr((($_ = $buff) =~ tr/\000-\037\177-\377//d, $_), 0, 60) };
my $TOSTR_DEBUG = sub { sprintf qq{DEBUG %s}, $TOSTR_UNKNOWN->($_[0]); };

my $DIALTYPE = "None";
my %TOSTR =
    ("TES3.HEDR" => sub { my($ver, $unk, $auth, $desc, $nrec) = unpack($RD{'TES3.HEDR'}, $_[0]);
			  $NREC = $nrec;
			  qq{  Ver:$ver  Unk:$unk\n\t\tAuthor:"$auth"\n\t\tDescription:"$desc"\n\t\tNRec:$NREC}; },
     "TES3.MAST" => sub { unpack($RD{'TES3.MAST'}, $_[0]) },
     "TES3.DATA" => sub { my($l1, $l2) = unpack($RD{'TES3.DATA'}, $_[0]);
			  my $size = $l1 + ($l2 << 32);
			  "Length:     $size"; },
     "ALCH.ALDT" => sub { sprintf "Weight: %0.2d  Value: %d  Autocalc: %d", unpack($RD{'ALCH.ALDT'}, $_[0]) },
     "APPA.AADT" => sub { my($type, $qual, $wght, $val) = unpack($RD{'APPA.AADT'}, $_[0]);
			  sprintf "Type: %s  Quality: %0.2f  Weight: %0.2f  Value: %d",
			      $APPARATUS_TYPE{$type}, $qual, $wght, $val },
     "ARMO.AODT" => sub { my($type, $wght, $value, $health, $epts, $armor) = unpack($RD{'ARMO.AODT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Health %d  Enchant_Points: %d  ArmorRating: %d",
			      $ARMOR_TYPE{$type}, $wght, $value, $health, $epts, $armor},
     "ARMO.INDX" => sub { $ARMOR_INDEX{unpack($RD{'ARMO.INDX'}, $_[0])} },
     "BODY.BYDT" => sub { my($part, $vamp, $flags, $ptype) = unpack($RD{'BODY.BYDT'}, $_[0]);
			  sprintf "Bodypart: %s  Vampire: %d  Flag: %s  PartType: %s",
			      $BYDT_PART{$part}, $vamp, dump_lookup($flags, \%BYDT_FLAGS), $BYDT_PTYP{$ptype}
		      },
     "BOOK.BKDT" => sub { my($wght, $val, $scrl, $skil, $epts) = unpack($RD{'BOOK.BKDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Scroll: %s  Skill: %d  Enchant_Points: %d",
			      $wght, $val, (1 == $scrl) ? "Yes" : "No", $skil, $epts },
     "CELL.AMBI" => sub { sprintf("Ambient Color: 0x%08x  Sunlight Color: 0x%08x  Fog Color: 0x%08x  Fog Density: %0.2f",
				unpack($RD{'CELL.AMBI'}, $_[0])); },
     "CELL.CSTN" => sub { sprintf "Target: %s", unpack($RD{'CELL.CSTN'}, $_[0]); },
     "CELL.DATA" => sub {
	 if (length($_[0]) == 24) {
	     sprintf("Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack("f6", $_[0]));
	 } else {
	     my($flags, $fog_den_data) = unpack("Lx[L]f", $_[0]);
	     my @flags = ();
	     my $coord = "";
	     my $data_fog_str = "";
	     if ($flags & 0x01) {
		 push(@flags, "Interior");
		 $data_fog_str = sprintf "FogDensity: %0.2f ", $fog_den_data;
	     } else {
		 push(@flags, "Exterior");
		 my($x, $y) = unpack("x[L]ll", $_[0]);
		 $coord = "Coordinates: ($x, $y) ";
	     }
	     my $flags_str = "Flags: " . decode_flags($flags, \@CELL_FLAGS);
	     $coord . $data_fog_str . $flags_str;
	 }
     },
     "CELL.FRMR" => sub { sprintf "ObjInd: %d ModInd: %d", unpack($RD{'CELL.FRMR'}, $_[0]); },
     "CELL.NAM5" => sub { "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'CELL.NAM5'}, $_[0]) },
     "CELL.NAM9" => sub { my $val = unpack($RD{'CELL.NAM9'}, $_[0]); (1 == $val) ? "Owner" : "Unk:$val"; },
     "CLAS.CLDT" => sub { my($attr1, $attr2, $spec, $min1, $maj1, $min2, $maj2, $min3, $maj3, $min4, $maj4, $min5, $maj5, $flags, $autoflags) =
			      unpack($RD{'CLAS.CLDT'}, $_[0]);
			  "  " . join("\n\t\t",
				      "Primary Attribute:   $ATTRIBUTE{$attr1}",
				      "Secondary Attribute: $ATTRIBUTE{$attr2}",
				      "Specialization: $SPECIALIZATION{$spec}",
				      "Major-Skill-1: $SKILL{$maj1}",
				      "Major-Skill-2: $SKILL{$maj2}",
				      "Major-Skill-3: $SKILL{$maj3}",
				      "Major-Skill-4: $SKILL{$maj4}",
				      "Major-Skill-5: $SKILL{$maj5}",
				      "Minor-Skill-1: $SKILL{$min1}",
				      "Minor-Skill-2: $SKILL{$min2}",
				      "Minor-Skill-3: $SKILL{$min3}",
				      "Minor-Skill-4: $SKILL{$min4}",
				      "Minor-Skill-5: $SKILL{$min5}",
				      "Flags: " . (($flags) ? "Playable" : "Non-playable"),
				      "AutoCalc Flags: " . decode_flags($autoflags, \@AUTOCALC_FLAGS));
		      },
     "CLOT.CTDT" => sub { my($type, $wght, $value, $epts) = unpack($RD{'CLOT.CTDT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Enchant_Points: %d",
			      $CTDT_TYPE{$type}, $wght, $value, $epts },
     "CLOT.INDX" => sub { unpack($RD{'CLOT.INDX'}, $_[0]) },
     "CONT.CNDT" => sub { sprintf "Weight: %0.2f", unpack($RD{'CONT.CNDT'}, $_[0]) },
     "CONT.FLAG" => sub { decode_flags(unpack($RD{'CONT.FLAG'}, $_[0]), \@CONTAINER_FLAGS) },
     "CREA.AI_W" => sub { my($hr, $idx) = $DECODE{'CREA.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"Idle_$_"} } 1..10);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{Distance}, $hr->{Duration}, $hr->{Time_of_day} },
#     "CREA.AIDT" => sub { join(", ", unpack($RD{'CREA.AIDT'}, $_[0])) },
     "CREA.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \@AIDT_FLAGS); },
     "CREA.FLAG" => sub { decode_flags(unpack($RD{'CREA.FLAG'}, $_[0]), \@CREATURE_FLAGS) },
     "CREA.NPDT" => sub { my($typ_i, $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
			     $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
			     $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold) = unpack($RD{'CREA.NPDT'}, $_[0]);
			  sprintf "Type: %s  Lev: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tHealth: %d  SpellPts: %d  Fatigue: %d  Soul: %d  Combat: %d  Magic: %d  Stealth: %d\n\t\tAttack-1 (%d, %d)  Attack-2: (%d, %d)  Attack-3 (%d, %d)  Gold: %d",
			      $CREA_TYPE[$typ_i], $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
				  $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
				      $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold;
		      },
     "DIAL.DATA" => sub { $DIALTYPE = $DIAL_TYPE{unpack($RD{'DIAL.DATA'}, $_[0])}; },
     "ENCH.ENDT" => sub { my($type, $cost, $chrg, $auto) = unpack($RD{'ENCH.ENDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Charge: %d  Autocalc: %d", $ENCHANT_TYPE{$type}, $cost, $chrg, $auto },
     "ENCH.ENAM" => sub { my($effect, $skill, $attr, $range, $area, $dur, $mmin, $mmax) = unpack($RD{'ENCH.ENAM'}, $_[0]);
			  my $spell = $SPELL_EFFECT{$effect};
			  if ($spell =~ /_attribute$/i) {
			      $spell .= "/$ATTRIBUTE{$attr}";
			  } elsif ($spell =~ /_skill$/i) {
			      $spell .= "/$SKILL{$skill}";
			  }
			  sprintf "%-28s  Range: %s  Area: %3d  Duration: %3d  MagMin: %4d  MagMax: %4d",
			      $spell, $RANGE_TYPE{$range}, $area, $dur, $mmin, $mmax },
     "FACT.FADT" => sub { my($attr1, $attr2, $rankdata, $skills, $unk, $flags) = unpack("LLa200a24LL", $_[0]);
			  my(@results) = sprintf "Attribute_1: %s  Attribute_2: %s  Unk:0x%x  Flags: %s",
			      $ATTRIBUTE{$attr1}, $ATTRIBUTE{$attr2}, $unk, decode_flags($flags, \@FACT_FLAGS);
			  push(@results, "\t\tFavored_Skills: " . join(", ", map { $SKILL{$_} } unpack("L6", $skills)));
			  foreach my $rd (unpack("(a20)10", $rankdata)) {
			      my($at1, $at2, $sk1, $sk2, $fact) = unpack("L5", $rd);
			      push(@results, sprintf "\t\tAttr_1: %3d  Attr_2: %3d  Skill_1: %3d  Skill_2: %3d  Fact: %3d",
				  $at1, $at2, $sk1, $sk2, $fact);
			  }
			  join("\n", @results);
		      },
     "INFO.ACDT" => sub { unpack($RD{'INFO.ACDT'}, $_[0]) }, # Actor Data? (only in .ess)
     "INFO.INAM" => sub { unpack($RD{'INFO.INAM'}, $_[0]) },
     "INFO.DATA" => sub { my($disp, $rank, $sex, $pcrank) = unpack($RD{'INFO.DATA'}, $_[0]);
			  $rank = "None" if $rank == 255;
			  $pcrank = "None" if $pcrank == 255;
			  if ($DIALTYPE eq "Journal") {
			      "JournalIndex: $disp";
			  } else {
			      "Disp:$disp  Rank:$rank  Sex:$SEX{$sex}  PCRank:$pcrank";
			  }},
     "INFO.ANAM" => sub { sprintf qq{Cell:       "%s"}, unpack($RD{'INFO.ANAM'}, $_[0]) },
     "INFO.BNAM" => sub { sprintf qq{Result:\n%s}, indent_result(unpack($RD{'INFO.BNAM'}, $_[0])) },
     "INFO.CNAM" => sub { sprintf qq{Class:      "%s"}, unpack($RD{'INFO.CNAM'}, $_[0]) },
     "INFO.DNAM" => sub { sprintf qq{PC Faction: "%s"}, unpack($RD{'INFO.DNAM'}, $_[0]) },
     "INFO.FNAM" => sub { sprintf qq{Faction:    "%s"}, unpack($RD{'INFO.FNAM'}, $_[0]) },
     "INFO.NAME" => sub { my $str = unpack($RD{'INFO.NAME'}, $_[0]); $str =~ tr/\r//d; sprintf qq{Response:   "%s"}, $str },
     "INFO.NNAM" => sub { sprintf qq{Next ID:    "%s"}, unpack($RD{'INFO.NNAM'}, $_[0]) },
     "INFO.ONAM" => sub { sprintf qq{Actor:      "%s"}, unpack($RD{'INFO.ONAM'}, $_[0]) },
     "INFO.PNAM" => sub { sprintf qq{Prev ID:    "%s"}, unpack($RD{'INFO.PNAM'}, $_[0]) },
     "INFO.RNAM" => sub { sprintf qq{Race:       "%s"}, unpack($RD{'INFO.RNAM'}, $_[0]) },
     "INFO.QSTN" => sub { my $val = unpack($RD{'INFO.QSTN'}, $_[0]);
			  (1 == $val) ? "Quest_Name" : "Unknown($val)" },
     "INFO.QSTF" => sub { my $val = unpack($RD{'INFO.QSTF'}, $_[0]);
			  (1 == $val) ? "Quest_Finished" : "Unknown($val)" },
     "INFO.QSTR" => sub { my $val = unpack($RD{'INFO.QSTR'}, $_[0]);
			  (1 == $val) ? "Quest_Restart" : "Unknown($val)" },
     "INFO.SCVR" => sub { my($idx, $typ, $fun, $cmp, $nam) = unpack($RD{'INFO.SCVR'}, $_[0]);
			  my $name = ($typ == 1) ? "" : "  Name:$nam";
			  sprintf "Index:$idx  Type:%s  Fun:%s  Cmp:%s$name",
			      dump_lookup($typ, \%INFO_SCVR_type), dump_lookup($fun, \%INFO_FUN), dump_lookup($cmp, \%INFO_SCVR_cmp); },
     "INGR.IRDT" => sub { my($hr, $idx) = $DECODE{'INGR.IRDT'}->($_[0]);
			  my $result = sprintf "Weight: %0.2f  Value: %d  Effects: ",
			      $hr->{Weight}, $hr->{Value};
			  my @results;
			  foreach my $i (1..4) {
			      if ($hr->{"Effect_$i"} != -1) {
				  my $eix = $hr->{"Effect_$i"};
				  my $effect = $SPELL_EFFECT{$eix} || "${eix}???";
				  if ($effect =~ /_attribute$/i) {
				      push(@results, qq{$effect/$ATTRIBUTE{$hr->{"Attribute_$i"}}}); # $attrs[$i]
				  } elsif ($effect =~ /_skill$/i) {
				      push(@results, qq{$effect/$SKILL{$hr->{"Skill_$i"}}}); # $skills[$i]
				  } else {
				      push(@results, "$effect");
				  }
			      }
			  }
			  $result . join(", ", @results);
		      },
     "LAND.INTV" => sub { sprintf qq{Coordinates: (%d, %d)}, unpack($RD{'LAND.INTV'}, $_[0]) },
     "LEVC.DATA" => sub { "List Data: %d (1 = Calc from all levels <= PC level)", unpack($RD{'LEVC.DATA'}, $_[0]) },
     "LEVC.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVC.INTV'}, $_[0]) },
     "LEVC.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVC.NNAM'}, $_[0]) },
     "LEVI.DATA" => sub { "List Data: %s ", $LEVI_DATA{unpack($RD{'LEVI.DATA'}, $_[0])} },
     "LEVI.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVI.INTV'}, $_[0]) },
     "LEVI.INAM" => sub { unpack($RD{'LEVI.INAM'}, $_[0]) },
     "LEVI.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVI.NNAM'}, $_[0]) },
     "LIGH.LHDT" => sub { my($wght, $value, $time, $radius, $red, $green, $blue, $null, $flags) = unpack($RD{'LIGH.LHDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Time: %d  Radius: %d  RGB: (%x, %x, %x)  Flags: %s",
			      $wght, $value, $time, $radius, $red, $green, $blue, decode_flags($flags, \@LHDT_FLAGS) },
     "LOCK.LKDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'LOCK.LKDT'}, $_[0]) },
     "LTEX.DATA" => sub { unpack($RD{'LTEX.DATA'}, $_[0]) },
     "MGEF.MEDT" => sub { my($school, $base, $flags, $red, $blue, $green, $speed, $size, $sizecap) = unpack($RD{'MGEF.MEDT'}, $_[0]);
			  sprintf "School: %s  BaseCost: %0.2f  Flags: %s  RGB: (%x, %x, %x)  SizeX: %0.2f  SizeCap: %0.2f",
			      $MAGIC_SCHOOL{$school}, $base, decode_flags($flags, \@MGEF_FLAGS), $red, $blue, $green, $size, $sizecap },
     "MISC.MCDT" => sub { sprintf "Weight: %0.2f  Value: %d  Unk:%0x", unpack($RD{'MISC.MCDT'}, $_[0]) },
#     "NPC_.ANAM" => $TOSTR_UNKNOWN,
#     "NPC_.KNAM" => $TOSTR_UNKNOWN,
     "NPC_.CNDT" => sub { unpack($RD{'NPC_.CNDT'}, $_[0]) },
     "NPC_.FLAG" => sub { decode_flags(unpack($RD{'NPC_.FLAG'}, $_[0]), \@NPC_FLAGS) },
     "NPC_.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \@AIDT_FLAGS); },
     "NPC_.AI_W" => sub { my($hr, $idx) = $DECODE{'NPC_.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"Idle_$_"} } 1..8);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{Distance}, $hr->{Duration}, $hr->{Time_of_day} },
     "NPC_.NPDT" => sub { my($hr, $idx) = $DECODE{'NPC_.NPDT'}->($_[0]);
			  if (exists $hr->{Str}) { # long form
			      my $skills = "";
			      my $n = 0;
			      foreach my $skill (sort values %SKILL) {
				  $skills .= "\n\t\t" if (($n++ % 7) == 0);
				  $skills .= " $skill: $hr->{$skill}";# if (defined $hr->{$skill});
			      }
			      sprintf "  Level: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tRep: %d  Health: %d SpellPts: %d  Fatigue: %d  Disp: %d  Faction: %d  Rank: %d  Gold: %d\n\t\tSkills:$skills",
				  $hr->{Level}, $hr->{Str}, $hr->{Int}, $hr->{Wil}, $hr->{Agi}, $hr->{Spd},
				      $hr->{End}, $hr->{Per}, $hr->{Lck}, $hr->{Rep}, $hr->{Health}, $hr->{Magicka},
					  $hr->{Fatigue}, $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold};
			  } else {		   # short form (autocalced)
			      sprintf "Level: %d  Disposition: %d  Faction: %d  Rank: %d  Gold: %d",
				  $hr->{Level}, $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold};
			  }
		      },
     "PCDT.SNAM" => $TOSTR_UNKNOWN, # .ess
     "PCDT.ENAM" => $TOSTR_UNKNOWN, # .ess
     "PCDT.FNAM" => $TOSTR_UNKNOWN, # .ess
     "PROB.PBDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'PROB.PBDT'}, $_[0]) },
     "QUES.DATA" => sub { sprintf "INFO_ID: %s", unpack($RD{'QUES.DATA'}, $_[0]) }, # only in .ess (relates back to Actor in INFO)
     "RACE.RADT" => sub { my($hr, $idx) = $DECODE{'RACE.RADT'}->($_[0]);
			  my $result = sprintf "Flags: %s  Male_Height: %0.2f  Male_Weight: %0.2f  Female_Height: %0.2f  Female_Weight: %0.2f",
			      decode_flags($hr->{Flags}, \@RADT_FLAGS), $hr->{Male_Height}, $hr->{Male_Weight},
				  $hr->{Female_Height}, $hr->{Female_Weight};
			  $result .= "\n\t\tSkill Bonuses:";
			  foreach my $i (1..7) {
			      my($skill_id, $bonus) = ($hr->{"Skill_$i"}, $hr->{"Bonus_$i"});
			      $result .= sprintf("\n\t\t%-12s %3d", $SKILL{$skill_id}, $bonus);
			  }
			  my @attr_names = qw(Strength Intelligence Willpower Agility Speed Endurance Personality Luck);
			  $result .= "\n\t\tBase Attributes: Male/Female";
			  foreach my $i (1..8) {
			      my($male, $female) = ($hr->{"Attr_Male_$i"}, $hr->{"Attr_Female_$i"});
			      $result .= sprintf("\n\t\t%-12s    %3d  %3d", shift(@attr_names), $male, $female);
			  }
			  $result;
		      },
     "REGN.WEAT" => sub { sprintf "Clear: %d  Cloudy: %d  Foggy: %d  Overcast: %d  Rain: %d  Thunder: %d  Ash: %d  Blight: %d",
			      unpack($RD{'REGN.WEAT'}, $_[0]) },
     "REGN.CNAM" => sub { "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'REGN.CNAM'}, $_[0]) },
     "REGN.SNAM" => sub { "Chance: %3d  SoundName: %s", unpack($RD{'REGN.SNAM'}, $_[0]) },
     "REGN.WNAM" => sub { unpack($RD{'REGN.WNAM'}, $_[0]); },
     "REPA.RIDT" => sub { sprintf "Weight: %0.2f  Value: %d  Uses: %d  Quality: %0.2f", unpack($RD{'REPA.RIDT'}, $_[0]); },
     "SCPT.RNAM" => sub { sprintf "Unk:%x", unpack($RD{'SCPT.RNAM'}, $_[0]) },
     "SCPT.SCDT" => sub { if (DBG) { unpack($RD{'SCPT.SCDT'}, $_[0]) } else { "(Compiled script data)" }; },
     "SCPT.SCHD" => sub { sprintf "Name: %s  NumShorts: %d  NumLongs: %d  NumFloats: %d  ScriptDataSize: %d  LongVarSize: %d",
			      unpack($RD{'SCPT.SCHD'}, $_[0]); },
     "SCPT.SCVR" => sub { "Script Variables: " . join(',', split(/\000/, unpack($RD{'SCPT.SCVR'}, $_[0]))) },
     "SCPT.SCTX" => sub { "Script:\n" . unpack($RD{'SCPT.SCTX'}, $_[0]) },

     "SKIL.SKDT" => sub { my($attr, $spec, @usevals) = unpack($RD{'SKIL.SKDT'}, $_[0]);
			  sprintf "Attribute: %s  Specialization: %s  UseValues: %0.2f %0.2f %0.2f %0.2f",
			      $ATTRIBUTE{$attr}, $SPECIALIZATION{$spec}, @usevals},
     "SNDG.DATA" => sub { qq{"$SNDG_DATA[unpack($RD{'SNDG.DATA'}, $_[0])]"}; },
     "SPEL.SPDT" => sub { my($type, $cost, $flags) = unpack($RD{'SPEL.SPDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Flags: %s", $SPEL_TYPE{$type}, $cost, decode_flags($flags, \@SPEL_FLAGS) },
     "SPLM.NAME" => sub { unpack($RD{'SPLM.NAME'}, $_[0]); },
     "SPLM.SPDT" => sub {
	 # SPDT is 160 bytes long
	 my($type, $spell, $long2, $long3, $caster, $item) = unpack($RD{'SPLM.SPDT'}, $_[0]);
	 sprintf qq{Type: %s  Name: "%s"  long2:%s  long3: %d  caster: "%s"  Item: "%s"},
	     $SPLM_TYPE{$type}, $spell, dbg_ulong($long2), $long3, $caster, $item;
     },
     "SPLM.NPDT" => sub {
	 # NPDT is 56 bytes long
	 my($name, $mag, $long2, $long3, $long4) = unpack($RD{'SPLM.NPDT'}, $_[0]);
	 sprintf qq{name: "%s"  magnitude: %d  long2:%s  long3: %d  long4: %d},
	     $name, $mag, dbg_ulong($long2), $long3, $long4;
     },
     "SPLM.XNAM" => sub { sprintf "%d", unpack($RD{'SPLM.XNAM'}, $_[0]); },
     "SPLM.TNAM" => sub { sprintf "Target: %s", unpack($RD{'SPLM.TNAM'}, $_[0]); },
     "SOUN.DATA" => sub { sprintf "Volume: %d  MinRange: %d  MaxRange: %d", unpack($RD{'SOUN.DATA'}, $_[0]) },
     "SSCR.DATA" => sub { unpack($RD{'SSCR.DATA'}, $_[0]) },
     "STLN.ONAM" => sub { unpack($RD{'STLN.ONAM'}, $_[0]) },
     "WEAP.WPDT" => sub { my($wght, $value, $type, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $flags) = unpack($RD{'WEAP.WPDT'}, $_[0]);
		      sprintf " Wght: %0.2f  Val: %d  Typ: %s  Hlth: %d  Spd: %0.2f  Rch: %0.2f\n\t\tEnchant_Points: %d  Chop: %d-%d  Slash: %d-%d Thrust: %d-%d  Flags: %s",
			  $wght, $value, $WEAPON_TYPE{$type}, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $WEAPON_FLAGS{$flags}},
     "VFXM.VNAM" => sub {
	 my($long1, $long2, $long3, $long4, $long5, $long6, $short1, $hex1, $name2, $name3) =
	     unpack($RD{'VFXM.VNAM'}, $_[0]);
	 sprintf "\n  long1:%s\n  long2:%s\n  long3:%s\n  long4:%s\n  long5:%s\n  long6:%s\n  short1:%d\n  unk1:[%s]\n  name2: %s\n  name3: %s\n",
	     dbg_ulong($long1), dbg_ulong($long2), dbg_ulong($long3), dbg_ulong($long4), dbg_ulong($long5), dbg_ulong($long6), $short1, $TOSTR_UNKNOWN->($hex1), $name2, $name3;
     },

     # The following are common subrecord formats
     DELE => sub { "DELETED" },
     DODT => sub { sprintf "Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack($RD{'DODT'}, $_[0]) },
     FLAG => sub { sprintf "hexflags:0x%04x", unpack($RD{'FLAG'}, $_[0]) },
     NPCO => sub { sprintf 'Count=%d  Name="%s"', unpack("lZ*", $_[0]) }, # codec must use a32 for NAME
     XCHG => sub { sprintf "Enchant_Charge: %0.2f", unpack($RD{'XCHG'}, $_[0]) },
     XHLT => sub { sprintf "Health: %d", unpack($RD{'XHLT'}, $_[0]) },
     XSCL => sub { sprintf "Scale: %0.2f", unpack($RD{'XSCL'}, $_[0]) },
     XSOL => sub { sprintf "Soul: %s", unpack($RD{'XSOL'}, $_[0]) },
     WIDX => sub { my($idx, $ammo) = unpack($RD{'WIDX'}, $_[0]);
		   $ammo = ($ammo == 0) ? "" : " (Ammo)";
		   sprintf "Equipped_Idx:%3d$ammo",  $idx }, # JMS index into NPCO inventory items of those that are equipped
     SLCS => sub { sprintf "Shorts: %d  Longs: %d  Floats: %d", unpack($RD{'SLCS'}, $_[0]) }, # .ess
     SLSD => sub { sprintf "Short_Vals: " . join(", ", unpack($RD{'SLSD'}, $_[0])) }, # .ess
     SLLD => sub { sprintf "Long_Vals: " . join(", ", unpack($RD{'SLLD'}, $_[0])) }, # .ess
     SLFD => sub { sprintf "Float_Vals: " . join(", ", map { sprintf "%0.2f", $_ } join(", ", unpack($RD{'SLFD'}, $_[0]))) }, # .ess
    );

$TOSTR{"SPEL.ENAM"} = $TOSTR{"ENCH.ENAM"};

# subrecords that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $TOSTR{$_} = sub { unpack("l", $_[0]) }; }

# subrecords that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX))
    { $TOSTR{$_} = sub { unpack("L", $_[0]) }; }

# subrecords that decode as 32-bit floats:
foreach (qw(FLTV WHGT))
    { $TOSTR{$_} = sub { sprintf "%0.2f", unpack("f", $_[0]) }; }

# subrecords that decode as variable length Z-strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FNAM
HSND HVFX ITEX KNAM LSTN MNAM MODL NAME NPCS PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TNAM WNAM))
    { $TOSTR{$_} = sub { unpack("Z*", $_[0]) }; }

sub opts_dump {
    $_[0] && do { die $DUMP_USAGE; };
    getopts('c:Df:F:i:lm:M:nNRrs:t:') or die $DUMP_USAGE;
}

my $REN_USAGE = q{Usage: tes3cmd rename OPTIONS RECTYPE.SUBTYPE FROM TO plugin...

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME subrecord matches
the given FROM regular expression.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

tes3cmd rename -l RECTYPE.SUBTYPE plugin...

When the -l switch is given, records of the given type are only listed. (You
do not give a FROM or TO when using the -l option).

OPTIONS
 -D   turn on debug output
 -i   only rename if the record is an interior CELL.
 -e   only rename if the record is an exterior CELL.
 -l   just list the records, do not rename them.
 -w   size of printable window for record contents printed with -l switch.

The original input file is renamed to a backup, and changes are output ot the
original filename.

Note that when renaming scripts, you can use either SCPT.SCTX or SCPT.SCHD as
the RECTYPE.SUBTYPE parameter, and the script name is changed in both
subrecords.

Examples:

# rename all exterior cells to the null string:
tes3cmd rename -e CELL.NAME ".*" "" plugin.esp

# do a caseless comparison with the FROM pattern:
tes3cmd rename cell.name "(?i)pelagaid" "Pelagiad" plugin.esp
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# The following command will swap the first and last name of all NPCs using
# substitution backreferences (a very powerful feature of regular expressions):
tes3cmd rename npc_.fnam "^(\S+)\s(\S+)$" "$2 $1" plugin.esp
(Note that on Linux you may need to use single-quotes instead of double-quotes).
};

my($REN_FROM, $REN_TO, $REN_TYPE, $REN_SUBTYPE);
my @ren_valid_types = qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
		     SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
		     DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
		     CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
		     ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
		     REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
		     LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
		     ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME SCPT.SCHD SCPT.SCTX);
my %VALID_TYPES;
$VALID_TYPES{$_}++ foreach (@ren_valid_types);

sub opts_rename {
    $_[0] && do { die $REN_USAGE; };
    $::opt_v = 0;
    $::opt_l = 0;
    $::opt_i = 0;
    $::opt_e = 0;
    $::opt_w = 38;
    getopts('Deilvw:') or die $REN_USAGE;

    my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$REN_USAGE";
    die "Error: Invalid record type.subtype requested: $type\n\nI only know these:\n@ren_valid_types\n" unless ($VALID_TYPES{$type});
    ($REN_TYPE, $REN_SUBTYPE) = split(/\./, $type);

    unless ($::opt_l) {
	defined($REN_FROM = shift(@ARGV)) or die "Missing required FROM\n$REN_USAGE";
	defined($REN_TO = shift(@ARGV)) or die "Missing required TO\n$REN_USAGE";
    }
}

my $HDR_USAGE = q{Usage: tes3cmd header OPTIONS plugin...

OPTIONS
 -D      turn on debug output
 -a XXX  set the Author field to the value XXX
 -d YYY  set the Description field to value YYY
 -m      multi-line output for listing field contents.

When -a and -d are not given, the current Author/Description field contents
are printed.

Field values are normally replaced by the given string. But if the string
begins with a "+", the existing value is appended with the new given value.

If a given value contains the string "\\n", it will be replaced by a CRLF.

Note:
 - the Author value should fit in 31 bytes.
 - the Description value should fit in 255 bytes.

If the value supplied won't fit into the plugin header field, you will be
warned.

Examples:

# Show the Author/Description fields for a plugin:
tes3cmd header plugin.esp

# Set the Author field to "john.moonsugar":
tes3cmd header -a john.moonsugar plugin.esp

# Append " and friends" to the Author field:
tes3cmd header -a "+ and friends" plugin.esp

# Add a Version number to a plugin Description field:
tes3cmd header -d "+\nVersion: 1.0" plugin.esp
};

my $HDR_AUTH_OFFSET = 32;
my $HDR_AUTH_LENGTH = 32;
my $HDR_DESC_OFFSET = $HDR_AUTH_OFFSET + $HDR_AUTH_LENGTH;
my $HDR_DESC_LENGTH = 256;

sub opts_header {
    $_[0] && do { die $HDR_USAGE; };
    $::opt_v = 0;
    $::opt_a = "";
    $::opt_d = "";
    $::opt_m = undef;
    $::opt_v = 0.0;
    getopts('Da:d:mv:') or die $HDR_USAGE;
}

my %CMDS = (
	    "cellnamepatch" => [ \&opts_cellnamepatch, \&cmd_cellnamepatch ],
	    "common"   => [ \&opts_com,      \&cmd_com ],
	    "overdial" => [ \&opts_overdial, \&cmd_overdial ],
	    "delete"   => [ \&opts_delete,   \&cmd_delete ],
	    "dump"     => [ \&opts_dump,     \&cmd_dump ],
	    "esp"      => [ \&opts_esp,      \&cmd_esp ],
	    "esm"      => [ \&opts_esm,      \&cmd_esm ],
	    "fogpatch" => [ \&opts_fogpatch, \&cmd_fogpatch ],
	    "header"   => [ \&opts_header,   \&cmd_header ],
	    "help"     => [ \&opts_help,     undef ],
	    "modify"   => [ \&opts_modify,   \&cmd_modify ],
	    "rename"   => [ \&opts_rename,   \&cmd_rename ],
	    "diff"     => [ \&opts_diff,     \&cmd_diff ],
	   );

my $USAGE_ALL = qq{Usage: tes3cmd COMMAND OPTIONS plugins...

For help on commands: tes3cmd help command

COMMANDS
@{[join", ", keys %CMDS]}

};
sub add_alias {
    my($name, $alias) = @_;
    $CMDS{$alias} = $CMDS{$name};
    $USAGE_ALL .= " $alias is an alias for: $name\n"
}
# add shortcut aliases for convenience
add_alias("header", "hdr");
add_alias("rename", "ren");
add_alias("common", "com");
add_alias("overdial", "od");
add_alias("delete", "del");
add_alias("fogpatch", "fog");
add_alias("cellnamepatch", "cnp");
add_alias("modify", "mod");

sub opts_help {
    if (my $cmd_name = shift(@ARGV)) {
	if (my $cmd_ref = $CMDS{$cmd_name}) {
	    $cmd_ref->[0]->(1);	# exits
	} else {
	    die $USAGE_ALL;
	}
    }
    die $USAGE_ALL;
}

sub chop_nulls {
    my($str) = @_;
    return(unpack("Z*", $str));
}

sub write_header_field {
    my($plugin, $origval, $val, $label, $offset, $fieldlen) = @_;
    if ($val =~ /^\+(.*)$/) {
	$val = $origval . $1;
    }
    $val =~ s/(\\r|\r)?(\\n|\n)/\r\n/g;
    # create an empty null padded field
    my $valz = "\000" x $fieldlen;
    # truncate $val to fit in the field, if necessary
    my $origlen = length($val);
    $val = substr($val, 0, $fieldlen - 1);
    if (length($val) < $origlen) {
	print "Warning, input $label truncated because it exceeded field length of: $fieldlen\n";
    }
    # and plop the given string value into it, with at least one ending null
    substr($valz, 0, length($val)) = $val;
    unless(seek(PLUG, $offset, 0)) {
	print "$plugin: Error seeking to start of $label field at offset: $offset ($!)\n";
	return(undef);
    }
    my $len = length($valz);
    my $nwritten = syswrite(PLUG, $valz);
    if ($nwritten != $len) {
	print "$plugin: Error incomplete write to $label field ( ($!)\n";
	return(undef);
    }
    print qq{$plugin: $label set to: "$val"\n} unless ($::opt_q);
    return(1);
}

my @REC_FLAGS = ([0x0020, "Deleted"],
		 [0x0400, "Persistent"],
		 [0x1000, "Ignored"],
		 [0x2000, "Blocked"]);

my $hdr_size = 16;
sub read_rec {
    my($expected_type, $plugin) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	print "Read Error ($plugin header): asked for $hdr_size bytes, got $n_read\n";
	return(undef);
    }
    my($rec_type, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	print "Error ($plugin): Expected: $expected_type, got: $rec_type\n";
	return(undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	print "Read Error ($plugin rec): asked for $rec_len bytes, got $n_read\n";
	return(undef);
    }
    return($rec_type, $rec, $unk, $flags);
}

sub write_rec {
    my($rec_type, $rec, $unk, $flags) = @_;
    print OUT pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
}

sub subrec {
    my($type, $val) = @_;
    return(pack("a4La*", $type, length($val), $val));
}

sub parse_subrec_list {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $val]) if (defined $val);
	$p += $subrec_len;
    }
    return(\@subrecs);
}

# this version takes a little longer to execute
sub parse_subrec_hash_long {
    my($rec) = @_;
    print "DBG: calling parse_subrec_hash_long for rec=$rec\n" if (DBG);
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $val) if (defined $val);
	$p += $subrec_len;
    }
    return(\%r);
}

sub parse_subrec_hash {
    my($rec) = @_;
    my %r = ();
    my @parts = eval { unpack("(a4L/a*)*", $rec); };
    return(parse_subrec_hash_long($rec)) if ($@);
    while (@parts) {
	my $subrec_type = shift(@parts);
	my $subrec_val = shift(@parts);
	push(@{$r{$subrec_type}}, $subrec_val)
	    if (defined $subrec_val);
    }
    return(\%r);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub allowed_cell_type {
    my($sub_recs) = @_;
    return 1 unless ($::opt_i or $::opt_e);
    my $data;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($::opt_i) {
	return($flags & 1);	# is interior
    } else {			# opt_e
	return(not($flags & 1)); # is exterior
    }
}

sub pprec {
    my($rec, $subtype) = @_;
    print "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/[\000]+$//gm; tr/\r\n/ /; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $::opt_w));
}

sub make_backup {
    my($plugin) = @_;
    my $backup = $plugin;
    if (my($ext) = ($backup =~ /\.(es[mps])$/i)) {
	while (-f $backup) {
	    $backup =~ s/(?:~(\d+))?\.$ext$/'~' . ($1 + 1) . ".$ext"/e;
	}
	unless (rename($plugin, $backup)) {
	    die qq{Error renaming "$plugin" to "$backup" ($!)\n};
	}
	return($backup);
    } else {
	die qq{Error, "$plugin" name does not end in .esm/.esp/.ess\n};
    }
}

sub open_input_plugin {
    my($plugin, $mode) = @_;
    unless(open(INP, "<$plugin")) {
	die qq{Error opening "$plugin" for input ($!)\n};
    }
    unless (binmode(INP)) {
	close(INP);
	die "Error setting binmode on $plugin ($!)\n";
    }
}

sub ext_cell_name {
    my($r) = @_;
    my($x, $y) = unpack("x[L]ll", $r->{DATA}[0]);
    my $rgnn = chop_nulls($r->{RGNN}[0]) || "Wilderness";
    return("$rgnn ($x, $y)", $x, $y);
}

sub rec_id {
    my($r, $rec_type) = @_;
    if ($rec_type eq "INFO") {
	return(chop_nulls($r->{INAM}[0]));
    } elsif ($rec_type eq "CELL") {
	my $name = chop_nulls($r->{NAME}[0]);
	my $data = $r->{DATA}[0];
	my($flags) = unpack("L", $data);
	if ($flags & 1) {	# interior
	    return($name);
	} else {		# exterior
	    my($xname, $x, $y) = ext_cell_name($r);
	    return(($name) ? "$name ($x, $y)" : $xname);
	}
    } elsif ($rec_type eq "SCPT") {
	my $script = $r->{SCTX}->[0];
	my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
	return(lc($name));
    } elsif (defined $r->{NAME}) {
	return(lc(chop_nulls($r->{NAME}->[0])));
    } elsif (defined $r->{INDX}) {
	return(unpack("L", $r->{INDX}->[0]));
    } elsif ($rec_type eq "LAND") {
	my($x, $y) = unpack("ll", $r->{INTV}->[0]);
	return("($x, $y)");
    }
    return(undef);
}

sub read_object_ids {
    my($plugin, $fun) = @_;
    open_input_plugin($plugin);
    my %plugin_id = ();
    while(my($rec_type, $rec, $unk, $flags) = read_rec(undef, $plugin)) {
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	if ($fun) {
	    $fun->($rec_type, $id);
	} else {
	    $plugin_id{$rec_type}->{$id} = 1 if (defined $id);
	}
    }
    close(INP);
    return(\%plugin_id) unless ($fun);
}

sub read_dialogs {
    my($plugin, $dialref) = @_;
    open_input_plugin($plugin);
    while(my($rec_type, $rec, $unk, $flags) = read_rec(undef, $plugin)) {
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	next if ($rec_type ne "DIAL");
	my $r = parse_subrec_hash($rec);
	my $id = unpack("Z*", $r->{NAME}[0]);
	my $type = unpack("C", $r->{DATA}[0]);
	$dialref->{$plugin}->{$id}++ if ($type == 0 and $id);
    }
    close(INP);
}


sub print_header { print OUT $blank_header; }


sub cmd_fogpatch {
    my $datadir = find_datadir();
    print "Data Files = $datadir\n";
    my $datafiles = list_active($datadir);
    my $fogpatch = "$datadir/fogpatch.esp";
    unless(open(OUT, ">$fogpatch")) {
	print qq{Error opening "$fogpatch" for output ($!)\n};
	return;
    }
    unless(binmode(OUT, ':raw')) {
	print qq{Error setting binmode on "$fogpatch" ($!)\n};
	close(OUT);
	return;
    }
    my $n = 0;
    print_header();
    my %cell;
    foreach my $plugin (keys %{$datafiles}) {
	next unless ($plugin =~ /\.es[mp]$/i);
	$plugin = $datafiles->{$plugin};
	print "Scanning plugin: $plugin\n" if (DBG);
	open_input_plugin("$datadir/$plugin");
	my $expected = "TES3";
	while (my($rec_type, $rec, $unk, $flags) = read_rec($expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    next unless ($rec_type eq 'CELL');
	    my $r = parse_subrec_hash($rec);
	    my $data = $r->{DATA}[0];
	    my($flags, $fog_den_data) = unpack("Lx[L]f", $data);
	    if ($flags & 1) {	# interior cells
		if (not $flags & 128) { # behave like exterior
		    my $name = chop_nulls($r->{NAME}[0]);
		    my $ambi = $r->{AMBI}[0];
		    my $fog_den_ambi;
		    my $ambilen = length($ambi);
		    if ($ambilen == 16) {
			my $fog_den_ambi = unpack("x[L3]f", $ambi);
			if ($fog_den_ambi != $fog_den_data) {
			    $fog_den_data = 0.0 if ($fog_den_ambi == 0.0);
			    print "Warning, Fog Density in DATA ($fog_den_data) != AMBI ($fog_den_ambi)\n" if ($fog_den_data == 0.0);
			}
			if ($fog_den_data == 0.0 and not $cell{$name}) {
			    print "    FOGPATCH: $plugin\t\tCELL: $name\n";
			    # write NAME, DATA, AMBI
			    my $newrec = subrec("NAME", "$name\000");
			    substr($data, 8, 4) = pack("f", 0.01);
			    $newrec .= subrec("DATA", $data);
			    substr($ambi, 12, 4) = pack("f", 0.01);
			    $newrec .= subrec("AMBI", $ambi);
			    write_rec($rec_type, $newrec, $unk, $flags);
			    $n++;
			    $cell{$name} = 1;
			}
		    } else {
			print "Error: $plugin, CELL: $name, len(AMBI) subrec $ambilen != 16, skipping\n"
			    if ($ambilen != 0);
		    }
		}
	    }
	}
    }
    print qq{Patched $n cells in "$fogpatch"\n};
    close OUT;
    $::opt_a = "tes3cmd";
    $::opt_d = "Fogbug Patch";
    $::opt_q = 1;
    cmd_header($fogpatch);
}

# sort list of files by their modification date
sub sort_by_date {
    my($dir, @files) = @_;
    my $dirlist = list_files($dir);
    my @sorted = sort { (-M "$dir/$dirlist->{$b}") <=> (-M "$dir/$dirlist->{$a}") } @files;
    print qq{DBG: sorted files:\n}, join("\n", @sorted), "\n" if (DBG);
    return(@sorted);
}

sub cmd_cellnamepatch {
    my $datadir = find_datadir();
    print qq{Data Files is: "$datadir"\n};
    my $datafiles = list_active($datadir);
    my $patch_file = "cellnamepatch.esp";
    my $patch_path = "$datadir/$patch_file";
    unless(open(OUT, ">$patch_path")) {
	print qq{Error opening "$patch_path" for output ($!)\n};
	return;
    }
    unless(binmode(OUT, ':raw')) {
	print qq{Error setting binmode on "$patch_path" ($!)\n};
	close(OUT);
	return;
    }
    my $n = 0;
    print_header();
    my %cell;
    my @sorted = sort_by_date($datadir, keys %{$datafiles});
    my @plugins = (grep(/\.esm$/i, @sorted), grep(/\.esp$/i, @sorted));
    my %cell;
    foreach my $plugin (@plugins) {
	$plugin = $datafiles->{$plugin};
	next if ($plugin eq $patch_file);
	print "Scanning plugin: $plugin\n";
	open_input_plugin("$datadir/$plugin");
	my $expected = "TES3";
	while (my($rec_type, $rec, $unk, $flags) = read_rec($expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    next unless ($rec_type eq 'CELL');
	    my $r = parse_subrec_hash($rec);
	    my $data = $r->{DATA}[0];
	    my($flags) = unpack("L", $data);
	    unless ($flags & 1) {	# only do exterior cells
		my $name = chop_nulls($r->{NAME}[0]);
		my $coord = join(", ", unpack("x[L]ll", $r->{DATA}[0]));
		if (exists $cell{$coord}->{NAME}) {
		    my $prevname = $cell{$coord}->{NAME};
		    if ($prevname ne $name) {
			print qq{($coord) Redefined by: "$plugin" ["$prevname" -> "$name"]\n};
			if ($name eq $cell{$coord}->{ORIGNAME}) {
			    print qq{Not reverting to original name: "$cell{$coord}->{ORIGNAME}"\n};
			    $cell{$coord}->{OUTPUTFLAG}++;
			} elsif ($name) {
			    my $prevname = $cell{$coord}->{NAME};
			    my $prevplug = $cell{$coord}->{PLUG};
			    print qq{($coord) Replacing: [$prevplug]:"$prevname" with: [$plugin]:"$name"\n};
			    my $newrec = subrec("NAME", "$name\000") . subrec("DATA", $data);
			    $cell{$coord}->{NAME} = $name;
			    $cell{$coord}->{PLUG} = $plugin;
			    $cell{$coord}->{REC} = [$rec_type, $newrec, $unk, $flags];
			} else {
			    print qq{($coord) Skipping null name: [$plugin]:"$name"\n};
			}
		    }
		} else {
		    $cell{$coord}->{ORIGNAME} = $name;
		    $cell{$coord}->{ORIGPLUG} = $plugin;
		    $cell{$coord}->{NAME} = $name;
		    $cell{$coord}->{PLUG} = $plugin;
		}
	    }
	}
    }
    print "Saving patch file: $patch_file\n";
    foreach my $coord (%cell) {
	if ($cell{$coord}->{OUTPUTFLAG}) {
	    my $recref = $cell{$coord}->{REC};
	    if ($recref) {
		print qq{CELL: ($coord) -> NAME: "$cell{$coord}->{NAME}"\n};
		write_rec(@{$recref});
	    }
	}
    }
    close OUT;
    $::opt_a = "tes3cmd";
    $::opt_d = "cellnamepatch";
    $::opt_q = 1;
    cmd_header($patch_path);
}

sub cmd_overdial {
    my(@plugins) = @_;
    my %dialog;
    foreach my $plugin (@plugins) {
	read_dialogs($plugin, \%dialog);
    }
    my @testplugins = ($::opt_1) ? ($plugins[0]) : sort keys %dialog;
    foreach my $plugin1 (sort keys %dialog) {
	foreach my $plugin2 (@testplugins) {
	    if ($plugin1 ne $plugin2) {
		foreach my $id1 (keys %{$dialog{$plugin1}}) {
		    foreach my $id2 (keys %{$dialog{$plugin2}}) {
			if (length($id1) > length($id2) and $id1 =~ /\b$id2\b/i) {
			    printf qq{%-40s "$id1"\n%-40s "$id2"\n\n}, "$plugin1:", "$plugin2:";
			}
		    }
		}
	    }
	}
    }
}

# find objects in common between 2 plugins
sub cmd_com {
    my($plugin1, $plugin2) = @_;
    # swap plugins if plugin1 is larger than plugin2
    ($plugin1, $plugin2) = ($plugin2, $plugin1)
	if (-s $plugin1 > -s $plugin2);
    # read objects from smaller plugin
    my $objects1 = read_object_ids($plugin1);
    # compare to objects second plugin
    my $compare_fun = sub {
	my($rec_type, $id) = @_;
	if ($objects1->{$rec_type}->{$id}) {
	    print "  $rec_type: $id\n";
	}
    };
    read_object_ids($plugin2, $compare_fun);
}

sub read_objects {
    my($plugin, $fun) = @_;
    open_input_plugin($plugin);
    my %plugin_id = ();
    while(my($rec_type, $rec, $unk, $flags) = read_rec(undef, $plugin)) {
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	if ($fun) {
	    $fun->($rec_type, $id);
	} else {
	    $plugin_id{$rec_type}->{$id} = $rec if (defined $id);
	}
    }
    close(INP);
    return(\%plugin_id) unless ($fun);
}

sub output_diff {
    my($diff_file, $diff) = @_;
    if (@{$diff}) {
	if (open(OUT, ">$diff_file")) {
	    print OUT join("\n", @{$diff});
	    close(OUT);
	} else {
	    print "Error opening $diff_file for output ($!)\n";
	}
    }
}

sub cmd_diff {
    my($plugin1, $plugin2) = @_;
    my $ignore;
    if ($::opt_i) {
	$ignore = '^(\s+(?:' . join('|', split(/,/, $::opt_i)) . '):)\s.*$';
    }
    print "IGNORE = $ignore\n" if (DBG);
    my $obj1 = read_objects($plugin1);
    my $obj2 = read_objects($plugin2);
    my @p1_not_p2;	     # objects in plugin1 that do not exist in plugin2
    my @p2_not_p1;	     # objects in plugin2 that do not exist in plugin1
    my @p1_equal_p2;	     # objects in plugin1 that are equal in plugin2
    my @p1_diff_p2;	     # objects in plugin1 that are different in plugin2
    my @diffs;		     # detailed diffs
    my(@diff1, @diff2);
    foreach my $rec_type (sort keys %{$obj1}) {
	foreach my $id (sort keys %{$obj1->{$rec_type}}) {
	    if (defined(my $rec2 = $obj2->{$rec_type}->{$id})) {
		my $rec1 = $obj1->{$rec_type}->{$id};
		my $print_rec1 = rec_to_string($rec1, $rec_type, $plugin1);
		$print_rec1 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec1 =~ s/CELL.FRMR: ObjInd: \d+ ModInd: 0/CELL.FRMR: ObjInd: (IGNORED) ModInd: 0/gm;
		my $print_rec2 = rec_to_string($rec2, $rec_type, $plugin2);
		$print_rec2 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec2 =~ s/CELL.FRMR: ObjInd: \d+ ModInd: 0/CELL.FRMR: ObjInd: (IGNORED) ModInd: 0/gm;
		if ($print_rec1 eq $print_rec2) {
		    push(@p1_equal_p2, "$rec_type - $id");
		} else {
		    push(@p1_diff_p2, "$rec_type - $id");
		    push(@diff1, "\n$rec_type - $id");
		    push(@diff1, $print_rec1);
		    push(@diff2, "\n$rec_type - $id");
		    push(@diff2, $print_rec2);
		}
	    } else {
		push(@p1_not_p2, "$rec_type - $id");
	    }
	}
    }
    foreach my $rec_type (sort keys %{$obj2}) {
	foreach my $id (sort keys %{$obj2->{$rec_type}}) {
	    if (not defined $obj1->{$rec_type}->{$id}) {
		push(@p2_not_p1, "$rec_type - $id");
	    }
	}
    }
    # now print the diff report
    if (my $n = @p1_not_p2) {
	print qq{\nRecords in "$plugin1" not in "$plugin2" ($n):\n};
	foreach (@p1_not_p2) { print "$_\n"; }
    }
    if (my $n = @p2_not_p1) {
	print qq{\nRecords in "$plugin2" not in "$plugin1" ($n):\n};
	foreach (@p2_not_p1) { print "$_\n"; }
    }
    if (my $n  = @p1_equal_p2) {
	print qq{\nRecords that are equal in "$plugin1" and "$plugin2" ($n):\n};
	foreach (@p1_equal_p2) { print "$_\n"; }
    }
    my $diff1_file = fileparse($plugin1) . ".diff";
    my $diff2_file = fileparse($plugin2) . ".diff";
    if (my $n = @p1_diff_p2) {
	print qq{\nRecords that are different between "$plugin1" and "$plugin2" ($n):\n(Compare $diff1_file to $diff2_file)\n};
	foreach (@p1_diff_p2) { print "$_\n"; }
    }
    output_diff($diff1_file, \@diff1);
    output_diff($diff2_file, \@diff2);
}

sub read_match_files {
    if ($::opt_f) {
	my @pats;
	unless(open(MF, "<$::opt_f")) {
	    die qq{Error opening "$::opt_f" for input ($!)\n};
	}
	while (<MF>) {
	    chomp;
	    push(@pats, $_);
	}
	close(MF);
	if (scalar(@pats) > 0) {
	    push(@pats, $::opt_m) if ($::opt_m);
	    $::opt_m = '(?:' . join("|", @pats) . ')';
	}
    }
    if ($::opt_F) {
	my @pats;
	unless(open(MF, "<$::opt_F")) {
	    die qq{Error opening "$::opt_F" for input ($!)\n};
	}
	while (<MF>) {
	    chomp;
	    push(@pats, $_);
	}
	close(MF);
	if (scalar(@pats) > 0) {
	    push(@pats, $::opt_M) if ($::opt_M);
	    $::opt_M = '(?:' . join("|", @pats) . ')';
	}
    }
}

sub cmd_delete {
    my($plugin) = @_;
    read_match_files();
    my $oldplugin = make_backup($plugin);
    open_input_plugin($oldplugin);
    unless(open(OUT, ">$plugin")) {
	print qq{Error opening "$plugin" for output ($!)\n};
	return;
    }
    unless(binmode(OUT, ':raw')) {
	print qq{Error setting binmode on "$plugin" ($!)\n};
	close(OUT);
	return;
    }
    my $expected = "TES3";
    my $delete_ids;
    if ($::opt_i) {
	$delete_ids = '(' . join('|', split(/,/, $::opt_i)) . ')';
    }
    my %delete_types;
    my %delete_subtypes;
    if ($::opt_t) {
	foreach (split(/,/, $::opt_t)) {
	    # TBD - validate types?
	    my($type, $subtype) = split(/\./, $_);
	    if (length($type) != 4) {
		print qq{Invalid record type: "$_" (must be 4 characters long)\n};
		next;
	    }
	    $delete_types{lc($type)}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $delete_subtypes{lc("$type.$subtype")}++ if ($subtype);
		} else {
		    print qq{Invalid record subtype: "$_" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected, $plugin)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	my $nodelete = 0;
	if ($delete_ids) {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    $nodelete = 1 if ($id !~ /$delete_ids/i);
	}
	$nodelete = 1 if (%delete_types and not $delete_types{lc($rec_type)});
	if ($nodelete) {
	    write_rec($rec_type, $rec, $unk, $flags);
	    next;
	}
	my $p = 0;
	my $rec_len = length($rec);
	my $first = 1;
	my $print_rec = "";
	my $newrec = "";
	while ($p < $rec_len) {
	    my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	    $p += 8;
	    my $subrec = substr($rec, $p, $subrec_len);
	    $p += $subrec_len;
	    if (defined $subrec) {
		my $full_type = "${rec_type}.${subrec_type}";
		my $match = 0;
		if (not (%delete_subtypes and not $delete_subtypes{lc($full_type)})) {
		    my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type}  || $TOSTR_UNKNOWN;
		    my $subrec_str = $tostr->($subrec);
		    if ($::opt_s) {
			$match = 1 if ($::opt_m and $subrec_str =~ /$::opt_m/i);
			$match = 1 if ($::opt_M and $subrec_str !~ /$::opt_M/i);
		    }
		    print "DELETED SUBRECORD: $subrec_str\n" if ($match);
		    $print_rec .= "   $full_type: $subrec_str\n";
		}
		$newrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec) unless ($match);
	    } else {
		my $id = rec_id(parse_subrec_hash($rec), $rec_type);
		print "$plugin: Error, malformed subrec for ($rec_type $id) type=$subrec_type pos=$p len=$subrec_len\n";
	    }
	}
	if ($::opt_s) {
	    write_rec($rec_type, $newrec, $unk, $flags);
	} else {
	    if (($::opt_m and $print_rec =~ /$::opt_m/i) or
		($::opt_M and $print_rec !~ /$::opt_M/i)) {
		print "DELETED RECORD:\n$print_rec\n";
	    } else {
		write_rec($rec_type, $rec, $unk, $flags);
	    }
	}
    }
    close(INP);
    close(OUT);
    my($atime, $mtime) = (stat($oldplugin))[8,9];
    utime($atime, $mtime, $plugin);
    print "Output saved in: $plugin, Original backed up to: $oldplugin\n";
}

sub search_and_replace {
    my($x, $mref) = @_;
    my $type = ref($x);
    if ($type eq 'ARRAY') {
	foreach (@$x) {
	    if (ref($_) eq '') {
		${$mref} = 1 if eval qq{\$_ =~ s$::opt_r;};
	    } else {
		search_and_replace($_, $mref);
	    }
	}
    } elsif ($type eq 'HASH') {
	while (my($k, $v) = each %$x) {
	    if (ref($x->{$k}) eq '') {
		${$mref} = 1 if eval qq{\$x->{\$k} =~ s$::opt_r;};
	    } else {
		search_and_replace($x->{$k}, $mref);
	    }
	}
    } elsif ($type eq '') {
	my $x_before = $x;
	${$mref} = 1 if eval qq{\$_ =~ s$::opt_r;};
    }
}

sub run_code {
    my($rec_type, $r, $unk, $flags) = @_;
    my $mod = 0;
    search_and_replace($r, \$mod) if ($::opt_r);
    if ($::opt_e) {
	$mod ||= eval($::opt_e);
	if ($@) {
	    warn qq{Error running "$::opt_e" on: $rec_type ($@)\n};
	    $mod = 0;
	}
    }
    return(($mod) ? $r : undef)
}

sub encoder {
    my($full_type, $subrec_type) = @_;
    return($ENCODE{$full_type} || $ENCODE{$subrec_type});
}

sub cmd_modify {
    my($plugin) = @_;
    read_match_files();
    # load Perl program if specified with -p
    if ($::opt_p) {
	unless (do $::opt_p) {
	    die "Error reading $::opt_p ($!)\n" if ($!);
	    die "Error processing $::opt_p ($@)\n" if ($@);
	}
	$::opt_e = 'main($rec_type, $r, $unk, $flags);' if (not $::opt_e);
    }
    my $oldplugin = make_backup($plugin);
    open_input_plugin($oldplugin);
    unless(open(OUT, ">$plugin")) {
	print qq{Error opening "$plugin" for output ($!)\n};
	return;
    }
    unless(binmode(OUT, ':raw')) {
	print qq{Error setting binmode on "$plugin" ($!)\n};
	close(OUT);
	return;
    }
    my $expected = "TES3";
    my $modify_ids;
    if ($::opt_i) {
	$modify_ids = '(' . join('|', split(/,/, $::opt_i)) . ')';
    }
    my %modify_types;
    my %modify_subtypes;
    my $plugin_modified = 0;
    if ($::opt_t) {
	foreach (split(/,/, $::opt_t)) {
	    # TBD - validate types?
	    my($type, $subtype) = split(/\./, $_);
	    if (length($type) != 4) {
		print qq{Invalid record type: "$_" (must be 4 characters long)\n};
		next;
	    }
	    $modify_types{lc($type)}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $modify_subtypes{lc("$type.$subtype")}++ if ($subtype);
		} else {
		    print qq{Invalid record subtype: "$_" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    my $codec_ok = 1;
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected, $plugin)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	my $nomodify = 0;
	if ($modify_ids) {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    $nomodify = 1 if ($id !~ /$modify_ids/i);
	}
	$nomodify = 1 if (%modify_types and not $modify_types{lc($rec_type)});
	if ($nomodify) {
	    write_rec($rec_type, $rec, $unk, $flags);
	    next;
	}
	my $p = 0;
	my $rec_len = length($rec);
	my $first = 1;
	my $print_rec = "";
	my $newrec = "";
	my @subrecs = ();
	while ($p < $rec_len) {
	    my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	    $p += 8;
	    my $subrec = substr($rec, $p, $subrec_len);
	    $p += $subrec_len;
	    if (defined $subrec) {
		my $full_type = "${rec_type}.${subrec_type}";
		if (not (%modify_subtypes and not $modify_subtypes{lc($full_type)})) {
		    my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type}  || $TOSTR_UNKNOWN;
		    my $decoder = $DECODE{$full_type} || $DECODE{$subrec_type};
		    if (not $decoder) {
			die "can't find a decoder for $full_type or $subrec_type\n";
		    }
		    my($hr, $idx) = $decoder->($subrec);
		    my $subrec_str = $tostr->($subrec);
		    if ($::opt_s) {
			if (($::opt_m and $subrec_str =~ /$::opt_m/i) or
			    ($::opt_M and $subrec_str !~ /$::opt_M/i)) {
			    # subrecord matches, so run our code on it ...
			    warn "full_type=$full_type    subrec_type=$subrec_type\n";
			    if (my $newhr = run_code($full_type, $hr, $idx)) {
				my $encoder = $ENCODE{$full_type} || $ENCODE{$subrec_type};
				#warn "DBG: (newhr, idx)\n", Dumper([$newhr, $idx]), "\n";
				$subrec = $encoder->($newhr, $idx);
				$plugin_modified = 1;
				$subrec_str = $tostr->($subrec);
				print "MODIFIED SUBRECORD: $subrec_str\n";
			    } else {
				$subrec = undef;
			    }
			}
		    }
		    push(@subrecs, [$subrec_type, $hr, $idx]);
		    $print_rec .= "   $full_type: $subrec_str\n";
		    {	# DEBUG: double check codec orthogonality
			my $encoder = $ENCODE{$full_type} || $ENCODE{$subrec_type};
			if ($codec_ok and ($encoder->($hr, $idx) ne $subrec)) {
			    # we only print the first codec failure, it's more than enough :(
			    $codec_ok = 0;
			    warn "ERROR, codec failure on $full_type:\n";
			    warn Dumper({ hr => $hr, idx => $idx});
			}
		    }
		}
		$newrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec);
	    } else {
		my $id = rec_id(parse_subrec_hash($rec), $rec_type);
		print "$plugin: Error, malformed subrec for ($rec_type $id) type=$subrec_type pos=$p len=$subrec_len\n";
	    }
	}
	if ($::opt_s) {
	    write_rec($rec_type, $newrec, $unk, $flags);
	} elsif ($codec_ok) {
	    if (($::opt_m and $print_rec =~ /$::opt_m/i) or
		($::opt_M and $print_rec !~ /$::opt_M/i) or
		((not $::opt_m or $::opt_M) and ($::opt_e or $::opt_r))) {
		if (my $modrec = run_code($rec_type, \@subrecs, $unk, $flags)) {
		    $plugin_modified = 1;
		    $rec = '';
		    #warn "Modrec: ", Dumper($modrec), "\n";
		    foreach my $ref (@$modrec) {
			my($subrec_type, $hr, $idx) = @$ref;
			my $full_type = "${rec_type}.${subrec_type}";
			my $encoder = $ENCODE{$full_type} || $ENCODE{$subrec_type};
			#warn "DBG: (hr, idx)\n", Dumper([$hr, $idx]), "\n";
			my $subrec = $encoder->($hr, $idx);
			my $subrec_len = length($subrec);
			$rec .= pack("a4La*", $subrec_type, $subrec_len, $subrec);
		    }
		    print "MODIFIED RECORD:\n" . rec_to_string($rec, $rec_type, $plugin) . "\n";
		}
	    }
	    write_rec($rec_type, $rec, $unk, $flags);
	}
    }
    close(INP);
    close(OUT);
    if ($plugin_modified and $codec_ok) {
	my($atime, $mtime) = (stat($oldplugin))[8,9];
	utime($atime, $mtime, $plugin);
	print "Output saved in: $plugin, Original backed up to: $oldplugin\n";
    } else {
	unlink($plugin);
	rename($oldplugin, $plugin);
    }
}

sub rec_to_string {
    my($rec, $rec_type, $plugin, $flags, $unk, $n, $wanted_subtypes, $dial) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @print_rec;
    my $separator = $::opt_s || "\n    ";
    my($prefix, $unkstr);
    $prefix = "\n" unless ($::opt_s);
    if (DBG) {
	$prefix = "$plugin ";
	$unkstr = sprintf "  Unk:%04x", $unk;
    }
    my $dial_str = ($rec_type eq 'INFO') ? "  $dial" : '';
    my $flagstr = decode_flags($flags, \@REC_FLAGS);
    print "REC=$rec_type flags=$flagstr\n" if (DBG);
    my $recnum = ($::opt_N) ? $n : "";
    my $hdr = defined($flags) ? "${prefix}Record: $recnum  Flags: $flagstr${unkstr}${dial_str}$separator" : "";
    my @frmr_data;
    my $first_frmr_seen = 0;
    my $frmr_match = 0;
    # TBD, for opt_c, we seem to bung the fog density.
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	$p += $subrec_len;
	if (defined $subrec) {
	    my $full_type = "${rec_type}.${subrec_type}";
	    if (not ($wanted_subtypes and not $wanted_subtypes->{lc($full_type)})) {
		my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type}  || $TOSTR_UNKNOWN;
		my $subrec_str = $tostr->($subrec);
		if ($::opt_c and ($rec_type eq 'CELL')) {
		    if ($first_frmr_seen) {
			if ($subrec_type eq 'FRMR') {
			    if (join(" ", @frmr_data) =~ /$::opt_c/i) {
				$frmr_match++;
				push(@print_rec, @frmr_data);
			    }
			    @frmr_data = (); # start a new group
			}
			push(@frmr_data, "$full_type: $subrec_str");
		    } else {
			if ($subrec_type eq 'FRMR') {
			    # start the first FRMR group
			    $first_frmr_seen = 1;
			    push(@frmr_data, "$full_type: $subrec_str");
			} else {
			    # we push subrecs onto print_rec up until the first FRMR
			    push(@print_rec, "$full_type: $subrec_str");
			}
		    }
		} else {
		    push(@print_rec, "$full_type: $subrec_str");
		}
	    }
	} else {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    print "$plugin: Error, malformed subrec for ($rec_type $id) type=$subrec_type pos=$p len=$subrec_len\n";
	}
    }
    # if -c, check the last FRMR group
    if ($::opt_c) {
	if (join(" ", @frmr_data) =~ /$::opt_c/i) {
	    $frmr_match++;
	    push(@print_rec, @frmr_data);
	}
	return("") if (not $frmr_match);
    }
    return($hdr . join($separator, @print_rec));
}

sub cmd_dump {
    my($plugin) = @_;
    read_match_files();
    print "### Scanning $plugin\n" if ($::opt_v);
    open_input_plugin($plugin);
    my $expected = "TES3";
    my $wanted_ids;
    if ($::opt_i) {
	$wanted_ids = '(' . join('|', split(/,/, $::opt_i)) . ')';
    }
    my %wanted_types;
    my $wanted_subtypes;
    if ($::opt_t or $::opt_c) {
	my @type = split(/,/, $::opt_t);
	push(@type, 'CELL') if ($::opt_c);
	foreach (@type) {
	    # TBD - validate types?
	    my($type, $subtype) = split(/\./, $_);
	    if (length($type) != 4) {
		print qq{Invalid record type: "$_" (must be 4 characters long)\n};
		next;
	    }
	    $wanted_types{lc($type)}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $wanted_subtypes->{lc("$type.$subtype")}++ if ($subtype);
		} else {
		    print qq{Invalid record subtype: "$_" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    my $dial; 			# current dialog string, used for printing INFOs
    my $plugin_banner = ($::opt_R) ? $blank_header : "\n$plugin:\n";
    $plugin_banner = undef if ($::opt_r);
    $plugin_banner = undef if ($::opt_n);
    my $n = 1;
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected, $plugin)) {
	$expected = undef;
	last if not defined $rec_type;
	my $subrec_hash = parse_subrec_hash($rec);
	if ($wanted_ids) {
	    my $id = rec_id($subrec_hash, $rec_type);
	    next if ($id !~ /$wanted_ids/i);
	}
	if ($rec_type eq 'DIAL') {
	    $dial = '[' . $DIAL_TYPE{unpack("C", $subrec_hash->{DATA}->[0])} . ':' . unpack("Z*", $subrec_hash->{NAME}->[0]) . ']';
	}
	next if (%wanted_types and not $wanted_types{lc($rec_type)});
	$n = 0 if ($rec_type eq "TES3");
	my $print_rec = rec_to_string($rec, $rec_type, $plugin, $flags, $unk, $n, $wanted_subtypes, $dial);
	next if ($::opt_m and $print_rec !~ /$::opt_m/i);
	next if ($::opt_M and $print_rec =~ /$::opt_M/i);
	if ($print_rec and $plugin_banner) {
	    print $plugin_banner;
	    $plugin_banner = undef;
	}
	if ($::opt_l) {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    if ($rec_type eq 'CELL') {
		my $objcnt;
		while ($print_rec =~ /CELL.FRMR:/g) { $objcnt++; }
		printf "$rec_type: %-40s\t%5d objects\n", $id, $objcnt;
	    } else {
		print "$rec_type: $id\n";
	    }
	} elsif ($::opt_r or $::opt_R) {
	    if ($::opt_c and ($rec_type eq 'CELL')) {
		my @frmr_data;
		my $frmr_match = 0;
		my $subrecs = parse_subrec_list($rec);
		my @newrec = ();
		my $first_frmr_seen = 0;
		my $subrec_str = '';
		my $tostr;
		while (@$subrecs) {
		    my $subrecref = shift(@$subrecs);
		    my($subtype, $subrec) = @$subrecref;
		    $tostr = $TOSTR{"CELL.$subtype"} || $TOSTR{$subtype};
		    $subrec_str .= $tostr->($subrec);
		    if ($first_frmr_seen) {
			if ($subtype eq 'FRMR') {
			    if ($subrec_str =~ /$::opt_c/i) {
				$frmr_match++;
				push(@newrec, @frmr_data);
			    }
			    $subrec_str = '';
			    @frmr_data = (); # start a new group
			}
			push(@frmr_data, pack("a4L", $subtype, length($subrec)) . $subrec);
		    } else {
			if ($subtype eq 'FRMR') {
			    $first_frmr_seen = 1;
			    push(@frmr_data, pack("a4L", $subtype, length($subrec)) . $subrec);
			} else {
			    push(@newrec, pack("a4L", $subtype, length($subrec)) . $subrec);
			}
		    }
		}
		if ($subrec_str =~ /$::opt_c/i) {
		    $frmr_match++;
		    push(@newrec, @frmr_data);
		}
		if ($frmr_match) {
		    my $newrec = join("", @newrec);
		    print pack("a4LLLa*", $rec_type, length($newrec), $unk, $flags, $newrec);
		}
	    } else {
		print pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
	    }
	} else {
	    print "$print_rec\n" if ($print_rec);
	}
	$n++;
    }
    close(INP);
} # cmd_dump

sub cmd_rename {
    my($plugin) = @_;
    my $oldplugin = make_backup($plugin);
    if (not defined $oldplugin) {
	print "Error: unable to form backup name for $plugin\n";
	return;
    }
    print "\n$plugin: RENAMING Records:\n" unless ($::opt_l);
    open_input_plugin($oldplugin);
    unless($::opt_l) {
	unless(open(OUT, ">$plugin")) {
	    print qq{Error opening "$plugin" for output ($!)\n};
	    return;
	}
	unless(binmode(OUT, ':raw')) {
	    print qq{Error setting binmode on "$plugin" ($!)\n};
	    close(OUT);
	    return;
	}
    }
    my $expected = "TES3";
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected, $plugin)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($rec_type eq 'SCPT') {
	    my $renamed_schd = 0;
	    my $renamed_sctx = 0;
	    my($subrecs) = parse_subrec_list($rec);
	    foreach my $subrec (@{$subrecs}) {
		my $subtype = $subrec->[0];
		if ($subtype eq "SCHD") {
		    my($name, @schd_longs) = unpack("Z32L5", $subrec->[1]);
		    if ($::opt_l) {	# only list records
			printf qq{  $rec_type.$subtype  %-30s\n}, $name;
		    } else {
			my $newname;
			eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			if (length($newname) < 32) {
			    if ($name ne $newname) {
				$subrec->[1] = pack("Z32L5", $newname, @schd_longs);
				$renamed_schd = 1;
				printf qq{    Renaming: $rec_type.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			    }
			} else {
			    print qq{New name for script: "$newname" is too long, must be less than 32 bytes\n};
			}
		    }
		} elsif ($subtype eq "SCTX") {
		    my $script = $subrec->[1];
		    my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
		    if ($::opt_l) {	# only list records
			printf qq{  $rec_type.$subtype  %-30s\n}, $name;
		    } else {
			my $newname;
			eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			if ($name ne $newname) {
			    $script =~ s/^[^;]*?\bbegin\s+(\S+)/Begin $newname/im;
			    $subrec->[1] = $script;
			    $renamed_sctx = 1;
			    printf qq{    Renaming: $rec_type.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			}
		    }
		}
	    }
	    if (not $::opt_l) {
		if ($renamed_schd and $renamed_sctx) {
		    $rec = new_rec($subrecs);
		} else {
		    my $what = "";
		    $what .= " SCHD" unless $renamed_schd;
		    $what .= " SCTX" unless $renamed_sctx;
		    print "Error renaming$what, record NOT updated.\n";
		}
	    }
	} elsif ($rec_type eq $REN_TYPE) {
	    my $renamed = 0;
	    my($subrecs, $name_idx) = parse_subrec_list($rec);
	    if (defined($name_idx) and
		my $name = $subrecs->[$name_idx]->[1]) {
		$name = chop_nulls($name);
		if ($::opt_l) {	# only list records
		    my $recstr = pprec($rec, $REN_SUBTYPE);
		    printf qq{  $rec_type  %-30s [%s]\n}, $name, $recstr;
		} else {	# rename records
		    my $do_rename = 1;
		    $do_rename = 0 if ($rec_type eq "CELL" and not allowed_cell_type($subrecs));
		    if ($do_rename) {
			my $newname;
			eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			if ($name ne $newname) {
			    $subrecs->[$name_idx]->[1] = "$newname\000";
			    $renamed = 1;
			    printf qq{    Renaming: $REN_TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			}
		    }
		}
	    } else {
		print "Error, Record has no $REN_SUBTYPE subrecord: $rec\n";
	    }
	    $rec = new_rec($subrecs) if $renamed;
	}
	write_rec($rec_type, $rec, $unk, $flags) unless($::opt_l);
    }
    close(INP);
    unless ($::opt_l) {
	close(OUT);
	my($atime, $mtime) = (stat($oldplugin))[8,9];
	utime($atime, $mtime, $plugin);
	print "Output saved in: $plugin, Original backed up to: $oldplugin\n";
    }
}

sub cmd_header {
    my($plugin) = @_;
    unless(open(PLUG, "+<$plugin")) {
	print qq{Error opening "$plugin" for read/write ($!)\n};
	return;
    }
    unless(binmode(PLUG)) {
	print "Error setting binmode on $plugin ($!)\n";
	close(PLUG);
	return;
    }
    my $block;
    my $nread = read(PLUG, $block, 4096);
    if ($nread == 0) {
	print "$plugin: Error on intial read ($!)\n";
	close(PLUG);
	return;
    }
    my $magic = substr($block, 0, 4);
    if ($magic eq "TES3") {
	if ($nread >= 324) { 	# minimum TES3 plugin size
	    my $auth = chop_nulls(substr($block, $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH));
	    my $desc = chop_nulls(substr($block, $HDR_DESC_OFFSET, $HDR_DESC_LENGTH));
	    if ($::opt_a or $::opt_d) {
		if ($::opt_a) {
		    if (not defined write_header_field($plugin, $auth, $::opt_a, "AUTHOR", $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
		if ($::opt_d) {
		    if (not defined write_header_field($plugin, $desc, $::opt_d, "DESCRIPTION", $HDR_DESC_OFFSET, $HDR_DESC_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
	    } else {
		if ($::opt_m) {
		    print "$plugin:\n  AUTH=$auth\n  DESC=$desc\n";
		} else {
		    print "$plugin: AUTH=$auth DESC=$desc\n";
		}
	    }
	}
    } elsif ($magic eq "TES4") {
	print "This function is not yet implemented for TES4 files\n";
    } else {
	print "$plugin: Error, this does not appear to be an elder scrolls plugin\n";
    }
    close(PLUG);
}

sub convert_plugin {
    my($input) = @_;
    my $output;
    my $byte_expected;
    my $byte_new;
    if ($input =~ /\.esp$/i) {
	# convert plugin to master
	$byte_expected = "\000";
	$byte_new = "\001";
	($output = $input) =~ s/\.esp$/.esm/i;
    } else {
	# convert master to plugin
	$byte_expected = "\001";
	$byte_new = "\000";
	($output = $input) =~ s/\.esm$/.esp/i;
    }
    copy($input, $output) or die "Error, copy failed $input -> $output ($!)\n";
    eval {
	open(OUT, "+<$output") or die qq{Error opening "$output" for read/write ($!)};
	binmode(OUT) or die "Error setting binmode on $output ($!)";
	my $magic;
	(sysread(OUT, $magic, 4) == 4) or die "$output: Error reading magic ($!)";
	if ($magic eq "TES3") {
	    sysseek(OUT, 28, 0) or die "sysseek";
	    my $byte;
	    (sysread(OUT, $byte, 1) == 1) or die "$output: Error reading master byte ($!)\n";
	    my $val = unpack("C", $byte);
	    #warn "masterbyte = $val\n";
	    ($byte eq $byte_expected) or
		die qq{Error, expected master byte value of @{[unpack("C",$byte_expected)]}, got $val instead};
	    sysseek(OUT, 28, 0) or die "sysseek";
	    (syswrite(OUT, $byte_new, 1) == 1) or die "$output: Error writing master byte ($!)\n";
	} elsif ($magic eq "TES4") {
	    die "This function is not yet implemented for TES4 files";
	} else {
	    die "$output: Error, this does not appear to be Morrowind plugin";
	}
	close(OUT);
    };
    if ($@) {
	warn "$@\n";
	close(OUT);
	unlink($output);
	return;
    }
}

# convert a master to a plugin
sub cmd_esp {
    my($master) = @_;
    die "Error, input must be a master (.esm)\n"
	unless($master =~ /\.esm$/i);
    convert_plugin($master);
}

# convert a plugin to a master
sub cmd_esm {
    my($plugin) = @_;
    die "Error, input must be a plugin (.esp)\n"
	unless($plugin =~ /\.esp$/i);
    convert_plugin($plugin);
}

sub main {
    die $USAGE_ALL if (scalar(@ARGV) == 0);
    my $cmd_ref;
    my $cmd_name = shift(@ARGV);
    die $USAGE_ALL unless ($cmd_ref = $CMDS{$cmd_name});
    my($cmd_getopts, $cmd) = @{$cmd_ref};
    $cmd_getopts->();
    if ($cmd_name =~ /^(com(mon)?|overdial|diff|od|fog(patch)?|cnp|cellnamepatch)$/i) {
	$cmd->(@ARGV);
    } else {
	die $USAGE_ALL if (scalar(@ARGV) == 0);
	for my $plugin (@ARGV) {
	    $cmd->($plugin);
	}
    }
}

main();
